/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import{util as e,clone as t,env as a,scalar as n,keep as s,tensor as r,stack as o,concat as p,unstack as i,tidy as m,reshape as u,slice as d,io as c,Tensor as y}from"@tensorflow/tfjs-core";import{squaredDifference as l,pow as h,maximum as f,minimum as N,sub as g,floorDiv as b,divNoNan as x,div as T,mul as _,mod as S,addN as O,add as w,isNaN as A,prelu as E,leakyRelu as I,prod as v,rsqrt as D,relu6 as k,clipByValue as M,tan as V,tanh as z,square as C,sqrt as L,softplus as F,sinh as $,sign as R,sin as j,sigmoid as P,selu as B,round as H,relu as W,real as q,reciprocal as U,neg as G,imag as Q,log1p as K,log as X,floor as Z,expm1 as Y,exp as J,erf as ee,elu as te,cosh as ae,cos as ne,complex as se,ceil as re,atanh as oe,atan2 as pe,atan as ie,asinh as me,asin as ue,acosh as de,acos as ce,abs as ye,dilation2d as le,maxPool3d as he,avgPool3d as fe,maxPoolWithArgmax as Ne,maxPool as ge,avgPool as be,conv3d as xe,depthwiseConv2d as Te,conv2dTranspose as _e,fused as Se,conv2d as Oe,conv1d as we,zerosLike as Ae,zeros as Ee,truncatedNormal as Ie,range as ve,randomUniform as De,onesLike as ke,ones as Me,oneHot as Ve,multinomial as ze,linspace as Ce,fill as Le,setdiff1dAsync as Fe,cast as $e,whereAsync as Re,image as je,unique as Pe,topk as Be,scalar as He,tensor1d as We,where as qe,logicalOr as Ue,logicalNot as Ge,logicalAnd as Qe,lessEqual as Ke,less as Xe,greaterEqual as Ze,greater as Ye,notEqual as Je,equal as et,transpose as tt,einsum as at,matMul as nt,sparseToDense as st,logSoftmax as rt,softmax as ot,localResponseNormalization as pt,batchNorm as it,denseBincount as mt,bincount as ut,cumsum as dt,argMin as ct,argMax as yt,any as lt,all as ht,sum as ft,min as Nt,mean as gt,max as bt,gatherND as xt,scatterND as Tt,split as _t,tile as St,unstack as Ot,squeeze as wt,reshape as At,stack as Et,stridedSlice as It,slice as vt,reverse as Dt,gather as kt,concat as Mt,sparse as Vt,irfft as zt,rfft as Ct,ifft as Lt,fft as Ft,broadcastTo as $t,depthToSpace as Rt,batchToSpaceND as jt,spaceToBatchND as Pt,pad as Bt,mirrorPad as Ht,expandDims as Wt}from"@tensorflow/tfjs-core/dist/ops/ops_for_converter";var qt,Ut;!function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(qt||(qt={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(Ut||(Ut={}));const Gt={};function Qt(e,t){const a={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};Gt[e]=a}function Kt(e){return Gt[e]}function Xt(e){delete Gt[e]}function Zt(t,a,n,s,r){const o=a.inputParams[t];if(o&&void 0!==o.inputIndexStart){const t=o.inputIndexStart,p=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?t+1:o.inputIndexEnd;if("tensor"===o.type)return Yt(a.inputNames[o.inputIndexStart],n,s,r);if("tensors"===o.type){return a.inputNames.slice(t,p).map((e=>Yt(e,n,s,r)))}const i=Yt(a.inputNames.slice(t)[0],n,s,r),m=i.dataSync();return"number"===o.type?m[0]:e.toNestedArray(i.shape,m)}const p=a.attrParams[t];return p&&p.value}function Yt(e,t,a,n){const[s,r]=ta(e);if(null!=n){const e=n.getHashTableHandleByName(s);if(null!=e)return e}const o=a.currentContextIds.find((e=>!!t[ea(s,e)]));return void 0!==o?t[ea(s,o)][r]:void 0}function Jt(e,t){const[a,n]=ta(e);return[ea(a,t&&t.currentContextId),n]}function ea(e,t){return t?`${e}-${t}`:e}function ta(e){const t=e.split(":");if(1===t.length)return[e,0];return[t[0],Number(t[t.length-1])]}function aa(e,t,a){let n=Zt("pad",e,t,a);if("explicit"===n){n=Zt("explicitPaddings",e,t,a);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=n[2*e],s[e][1]=n[2*e+1];return s}return n}function na(e){return e.kept?e:t(e)}var sa=Object.freeze({__proto__:null,json:[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var ra=Object.freeze({__proto__:null,json:[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var oa=Object.freeze({__proto__:null,json:[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}]});var pa=Object.freeze({__proto__:null,json:[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]});var ia=Object.freeze({__proto__:null,json:[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]});var ma=Object.freeze({__proto__:null,json:[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var ua=Object.freeze({__proto__:null,json:[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]});var da=Object.freeze({__proto__:null,json:[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]});var ca=Object.freeze({__proto__:null,json:[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}]});var ya=Object.freeze({__proto__:null,json:[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}]});var la=Object.freeze({__proto__:null,json:[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var ha=Object.freeze({__proto__:null,json:[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}]});var fa=Object.freeze({__proto__:null,json:[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}]});var Na=Object.freeze({__proto__:null,json:[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]});var ga=Object.freeze({__proto__:null,json:[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}]});var ba=Object.freeze({__proto__:null,json:[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]});var xa=Object.freeze({__proto__:null,json:[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}]});class Ta{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[sa,ra,oa,pa,ia,ma,ua,la,ya,da,ha,fa,Na,ga,ba,xa,ca].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){const a=e.node,n=[],s=[],r=[],o=a.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?n.push(e[t.name]):"Const"===t.op?s.push(e[t.name]):null!=t.input&&0!==t.input.length||r.push(e[t.name]),e)),{});let p=[];const i=[];let m={},u={};null!=t&&(m=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));const d=Object.keys(o);d.forEach((e=>{const t=o[e];t.inputNames.forEach((e=>{const[a]=Jt(e);t.inputs.push(o[a]),o[a].children.push(t)}))})),0===Object.keys(u).length?d.forEach((e=>{const t=o[e];0===t.children.length&&i.push(t)})):Object.keys(u).forEach((e=>{const[t]=Jt(e),a=o[t];null!=a&&(a.signatureKey=u[e],i.push(a))})),Object.keys(m).length>0?Object.keys(m).forEach((e=>{const[t]=Jt(e),a=o[t];a&&(a.signatureKey=m[e],p.push(a))})):p=n;let c={};null!=e.library&&null!=e.library.function&&(c=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const y={nodes:o,inputs:p,outputs:i,weights:s,placeholders:n,signature:t,functions:c};return r.length>0&&(y.initNodes=r),y}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,a)=>(t[e[a].name]=a,t)),{})}mapNode(e){const t=Kt(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const a={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.substr(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr};return null!=t.inputs&&(a.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(a.attrParams=t.attrs.reduce(((t,a)=>{const n=a.type;let s;switch(a.type){case"string":s=Sa(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Sa(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":s=Va(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Va(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":s=wa(e.attr,a.tfName,a.defaultValue||0),void 0===s&&a.tfDeprecatedName&&(s=wa(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":s=Ma(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Ma(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":s=Oa(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Oa(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":s=Ca(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Ca(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":s=ka(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=ka(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":s=za(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=za(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":s=Ia(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Ia(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":s=va(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=va(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":s=Ea(e.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Ea(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return t[a.name]={value:s,type:n},t}),{})),a}mapFunction(e){const t=e.nodeDef,a=[];let n={};null!=t&&(n=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&a.push(e[t.name]),e)),{}));const s=[],r=[];e.signature.inputArg.forEach((e=>{const[t]=Jt(e.name),a={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Aa(e.type),type:"dtype"}},children:[]};a.signatureKey=e.name,s.push(a),n[t]=a}));Object.keys(n).forEach((e=>{const t=n[e];t.inputNames.forEach((e=>{const[a]=Jt(e);t.inputs.push(n[a]),n[a].children.push(t)}))}));const o=e.ret;e.signature.outputArg.forEach((e=>{const[t,a]=Jt(o[e.name]),s=n[t];null!=s&&(s.defaultOutput=a,r.push(s))}));const p=this.mapArgsToSignature(e);return{nodes:n,inputs:s,outputs:r,weights:a,placeholders:[],signature:p}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,a)=>(t[a.name]=this.mapArgToTensorInfo(a,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let a=e.name;return null!=t&&(a=t[a]),{name:a,dtype:e.type}}}function _a(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=a().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function Sa(e,t,a,n=!1){const s=e[t];return null!=s?_a(s.s,n):a}function Oa(e,t,a){const n=e[t];return n?n.b:a}function wa(e,t,a){const n=e[t]||{},s=null!=n.i?n.i:null!=n.f?n.f:a;return"number"==typeof s?s:parseInt(s,10)}function Aa(e){switch("string"==typeof e&&(e=qt[e]),e){case qt.DT_FLOAT:return"float32";case qt.DT_INT32:case qt.DT_INT64:case qt.DT_INT8:case qt.DT_UINT8:return"int32";case qt.DT_BOOL:return"bool";case qt.DT_DOUBLE:return"float32";case qt.DT_STRING:return"string";default:return null}}function Ea(e,t,a){const n=e[t];return n&&n.func?n.func.name:a}function Ia(e,t,a){const n=e[t];return n&&n.type?Aa(n.type):a}function va(e,t,a){const n=e[t];return n&&n.list&&n.list.type?n.list.type.map((e=>Aa(e))):a}function Da(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function ka(e,t,a){const n=e[t];return n&&n.shape?Da(n.shape):a}function Ma(e,t,a){const n=e[t];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):a}function Va(e,t,a,n=!1){const s=e[t];return s&&s.list&&s.list.s?s.list.s.map((e=>_a(e,n))):a}function za(e,t,a){const n=e[t];return n&&n.list&&n.list.shape?n.list.shape.map((e=>Da(e))):a}function Ca(e,t,a){const n=e[t];return n&&n.list&&n.list.b?n.list.b:a}class La{constructor(e,t,a){this.node=e,this.tensorMap=t,this.context=a,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return Yt(e,this.tensorMap,this.context)}getAttr(e,t){const a=this.node.rawAttrs[e];if(null!=a.tensor)return Yt(e,this.tensorMap,this.context);if(null!=a.i||null!=a.f)return wa(this.node.rawAttrs,e,t);if(null!=a.s)return Sa(this.node.rawAttrs,e,t);if(null!=a.b)return Oa(this.node.rawAttrs,e,t);if(null!=a.shape)return ka(this.node.rawAttrs,e,t);if(null!=a.type)return Ia(this.node.rawAttrs,e,t);if(null!=a.list){if(null!=a.list.i||null!=a.list.f)return Ma(this.node.rawAttrs,e,t);if(null!=a.list.s)return Va(this.node.rawAttrs,e,t);if(null!=a.list.shape)return za(this.node.rawAttrs,e,t);if(null!=a.list.b)return Ca(this.node.rawAttrs,e,t);if(null!=a.list.type)return va(this.node.rawAttrs,e,t)}return t}}function Fa(t,a,n=""){if("number"!=typeof t&&"number"!=typeof a){e.assert(t.length===a.length,(()=>n+` Shapes ${t} and ${a} must match`));for(let s=0;s<t.length;s++){const r=t[s],o=a[s];e.assert(r<0||o<0||r===o,(()=>n+` Shapes ${t} and ${a} must match`))}}}function $a(e){return"number"!=typeof e&&!e.some((e=>e<0))}function Ra(e,t,a){let n=ja(e,a);const s=!$a(n);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(s&&t.forEach((e=>{n=ja(e.shape,n)})),!$a(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function ja(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const a=[];for(let n=0;n<e.length;++n){const s=e[n],r=t[n];if(s>=0&&r>=0&&s!==r)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);a[n]=s>=0?s:r}return a}class Pa{constructor(e,t,a,r,o,p,i){this.name=e,this.dtype=t,this.maxSize=a,this.elementShape=r,this.identicalElementShapes=o,this.dynamicSize=p,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=n(0),s(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const a=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),Fa(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),a.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(a.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);a.tensor=t,s(t),a.written=!0,this.tensors[e]=a}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,a)=>this.write(e,t[a])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return r([],[0].concat(this.elementShape));const a=this.readMany(e);return Fa(this.elementShape,a[0].shape,"TensorArray shape mismatch: "),o(a,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return r([],[0].concat(this.elementShape));const t=[];for(let e=0;e<this.size();e++)t.push(e);const a=this.readMany(t);return Fa(this.elementShape,a[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${a[0].shape})`),p(a,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const a=Math.max(...e);if(!this.dynamicSize&&a>=this.maxSize)throw new Error(`Max index must be < array size (${a}  vs. ${this.maxSize})`);this.writeMany(e,i(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let a=0;const n=e.map((e=>(a+=e,a)));if(a!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${a}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===a?0:t.size/a,r=[];m((()=>{t=u(t,[1,a,s]);for(let a=0;a<e.length;++a){const o=[0,0===a?0:n[a-1],0],p=[1,e[a],s];r[a]=u(d(t,o,p),this.elementShape)}return r}));const o=[];for(let t=0;t<e.length;t++)o[t]=t;this.writeMany(o,r)}}class Ba{constructor(e,t,a,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=a,null!=e&&e.forEach((e=>{if(a!==e.dtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${e.dtype}`);Fa(t,e.shape,"TensorList shape mismatch: "),s(e)})),this.idTensor=n(0),this.maxNumElements=r,s(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Ba([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,a=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==a&&this.tensors.length!==a)throw new Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);Fa(e,this.elementShape,"TensorList shape mismatch: ");const n=Ra(this.elementShape,this.tensors,e);return m((()=>{const e=this.tensors.map((e=>u(e,n)));return o(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const a=Ra(this.elementShape,this.tensors,e),n=this.tensors.pop();return Fa(n.shape,e,"TensorList shape mismatch: "),u(n,a)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Fa(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");s(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,a){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);Fa(this.tensors[e].shape,t,"TensorList shape mismatch: ");const n=Ra(this.elementShape,this.tensors,t);return u(this.tensors[e],n)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Fa(this.elementShape,t.shape,"TensorList shape mismatch: "),s(t),this.tensors[e]=t}gather(e,t,a){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Fa(this.elementShape,a,"TensorList shape mismatch: "),e=e.slice(0,this.size());const n=Ra(this.elementShape,this.tensors,a);return 0===e.length?r([],[0].concat(n)):m((()=>{const t=e.map((e=>u(this.tensors[e],n)));return o(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Fa(this.elementShape,t,"TensorList shape mismatch: ");const a=Ra(this.elementShape,this.tensors,t);return 0===this.size()?r([],[0].concat(a)):m((()=>{const e=this.tensors.map((e=>u(e,a)));return p(e,0)}))}}const Ha=async(e,t,a)=>{switch(e.op){case"If":case"StatelessIf":{const n=Zt("thenBranch",e,t,a),s=Zt("elseBranch",e,t,a),r=Zt("cond",e,t,a),o=Zt("args",e,t,a);return(await r.data())[0]?a.functionMap[n].executeFunctionAsync(o,a.tensorArrayMap,a.tensorListMap):a.functionMap[s].executeFunctionAsync(o,a.tensorArrayMap,a.tensorListMap)}case"While":case"StatelessWhile":{const n=Zt("body",e,t,a),s=Zt("cond",e,t,a),r=Zt("args",e,t,a),o=await a.functionMap[s].executeFunctionAsync(r,a.tensorArrayMap,a.tensorListMap),p=r.map((e=>e.id));let i=await o[0].data();o.forEach((e=>{e.kept||-1!==p.indexOf(e.id)||e.dispose()}));let m=r;for(;i[0];){const e=m;m=await a.functionMap[n].executeFunctionAsync(m,a.tensorArrayMap,a.tensorListMap);const t=m.map((e=>e.id));e.forEach((e=>{e.kept||-1!==p.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const r=await a.functionMap[s].executeFunctionAsync(m,a.tensorArrayMap,a.tensorListMap);i=await r[0].data(),r.forEach((e=>{e.kept||-1!==p.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return m}case"LoopCond":return[na(Zt("pred",e,t,a))];case"Switch":{const n=Zt("pred",e,t,a);let s=Zt("data",e,t,a);return s.kept||(s=na(s)),(await n.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const n=e.inputNames.find((e=>void 0!==Yt(e,t,a)));if(n){return[na(Yt(n,t,a))]}return}case"Enter":{const n=Zt("frameName",e,t,a),s=Zt("tensor",e,t,a);return a.enterFrame(n),[na(s)]}case"Exit":{const n=Zt("tensor",e,t,a);return a.exitFrame(),[na(n)]}case"NextIteration":{const n=Zt("tensor",e,t,a);return a.nextIteration(),[na(n)]}case"TensorArrayV3":{const s=Zt("size",e,t,a),r=Zt("dtype",e,t,a),o=Zt("elementShape",e,t,a),p=Zt("dynamicSize",e,t,a),i=Zt("clearAfterRead",e,t,a),m=Zt("identicalElementShapes",e,t,a),u=Zt("name",e,t,a),d=new Pa(u,r,s,o,m,p,i);return a.addTensorArray(d),[d.idTensor,n(1)]}case"TensorArrayWriteV3":{const n=Zt("tensorArrayId",e,t,a),s=Zt("index",e,t,a),r=Zt("tensor",e,t,a),o=a.getTensorArray(n.id);return o.write(s,r),[o.idTensor]}case"TensorArrayReadV3":{const n=Zt("tensorArrayId",e,t,a),s=Zt("index",e,t,a);return[a.getTensorArray(n.id).read(s)]}case"TensorArrayGatherV3":{const n=Zt("tensorArrayId",e,t,a),s=Zt("indices",e,t,a),r=Zt("dtype",e,t,a);return[a.getTensorArray(n.id).gather(s,r)]}case"TensorArrayScatterV3":{const n=Zt("tensorArrayId",e,t,a),s=Zt("indices",e,t,a),r=Zt("tensor",e,t,a),o=a.getTensorArray(n.id);return o.scatter(s,r),[o.idTensor]}case"TensorArrayConcatV3":{const n=Zt("tensorArrayId",e,t,a),s=a.getTensorArray(n.id),r=Zt("dtype",e,t,a);return[s.concat(r)]}case"TensorArraySplitV3":{const n=Zt("tensorArrayId",e,t,a),s=Zt("tensor",e,t,a),r=Zt("lengths",e,t,a),o=a.getTensorArray(n.id);return o.split(r,s),[o.idTensor]}case"TensorArraySizeV3":{const s=Zt("tensorArrayId",e,t,a),r=a.getTensorArray(s.id);return[n(r.size(),"int32")]}case"TensorArrayCloseV3":{const n=Zt("tensorArrayId",e,t,a),s=a.getTensorArray(n.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const n=Zt("tensorListId",e,t,a),s=Zt("index",e,t,a),r=Zt("tensor",e,t,a),o=a.getTensorList(n.id);return o.setItem(s,r),[o.idTensor]}case"TensorListGetItem":{const n=Zt("tensorListId",e,t,a),s=Zt("index",e,t,a),r=Zt("elementShape",e,t,a),o=Zt("elementDType",e,t,a);return[a.getTensorList(n.id).getItem(s,r,o)]}case"TensorListScatterV2":case"TensorListScatter":{const n=Zt("indices",e,t,a),s=function(e,t,a,n){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=n&&-1!==n&&s>=n)throw new Error(`Max index must be < array size (${s}  vs. ${n})`);const r=new Ba([],a,e.dtype,n),o=i(e,0);return t.forEach(((e,t)=>{r.setItem(e,o[t])})),r}(Zt("tensor",e,t,a),n,Zt("elementShape",e,t,a),Zt("numElements",e,t,a));return a.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const n=Zt("elementShape",e,t,a),s=Zt("elementDType",e,t,a);let r;r="TensorListReserve"===e.op?"numElements":"maxNumElements";const o=function(e,t,a){return new Ba([],e,t,a)}(n,s,Zt(r,e,t,a));return a.addTensorList(o),[o.idTensor]}case"TensorListGather":{const n=Zt("tensorListId",e,t,a),s=Zt("indices",e,t,a),r=Zt("elementShape",e,t,a),o=Zt("elementDType",e,t,a);return[a.getTensorList(n.id).gather(s,o,r)]}case"TensorListStack":{const n=Zt("tensorListId",e,t,a),s=Zt("elementShape",e,t,a),r=Zt("elementDType",e,t,a),o=Zt("numElements",e,t,a);return[a.getTensorList(n.id).stack(s,r,o)]}case"TensorListFromTensor":{const n=function(e,t,a){const n=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==a)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${a}`);Fa(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=i(e);return new Ba(s,t,n)}(Zt("tensor",e,t,a),Zt("elementShape",e,t,a),Zt("elementDType",e,t,a));return a.addTensorList(n),[n.idTensor]}case"TensorListConcat":{const n=Zt("tensorListId",e,t,a),s=a.getTensorList(n.id),r=Zt("dtype",e,t,a),o=Zt("elementShape",e,t,a);return[s.concat(r,o)]}case"TensorListPushBack":{const n=Zt("tensorListId",e,t,a),s=Zt("tensor",e,t,a),r=a.getTensorList(n.id);return r.pushBack(s),[r.idTensor]}case"TensorListPopBack":{const n=Zt("tensorListId",e,t,a),s=Zt("elementShape",e,t,a),r=Zt("elementDType",e,t,a);return[a.getTensorList(n.id).popBack(s,r)]}case"TensorListSplit":{const n=Zt("tensor",e,t,a),s=Zt("elementShape",e,t,a),r=function(e,t,a){let n=0;const s=t.map((e=>(n+=e,n)));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${e.shape}`);const r=ja(e.shape.slice(1),a),o=0===n?0:e.size/n,p=m((()=>{const a=[];e=u(e,[1,n,o]);for(let n=0;n<t.length;++n){const p=[0,0===n?0:s[n-1],0],i=[1,t[n],o];a[n]=u(d(e,p,i),r)}return e.dispose(),a})),i=new Ba([],a,e.dtype,t.length);for(let e=0;e<p.length;e++)i.setItem(e,p[e]);return i}(n,Zt("lengths",e,t,a),s);return a.addTensorList(r),[r.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Wa(e,t,a){const[n,s]=Zt("fusedOps",e,t,a),r="biasadd"===n,o="prelu"===s,p="fusedbatchnorm"===n,i=Zt("numArgs",e,t,a);if(r){if(o&&2!==i)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==i)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(p)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const m=Zt("strides",e,t,a),u=aa(e,t,a),d=Zt("dataFormat",e,t,a).toUpperCase(),c=Zt("dilations",e,t,a),[y,l]=Zt("args",e,t,a);return{stride:m,pad:u,dataFormat:d,dilations:c,biasArg:y,preluArg:l,activationFunc:s,leakyreluAlpha:Zt("leakyreluAlpha",e,t,a)}}function qa(e,t,a){return{boxes:Zt("boxes",e,t,a),scores:Zt("scores",e,t,a),maxOutputSize:Zt("maxOutputSize",e,t,a),iouThreshold:Zt("iouThreshold",e,t,a),scoreThreshold:Zt("scoreThreshold",e,t,a),softNmsSigma:Zt("softNmsSigma",e,t,a)}}class Ua{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=n(0),this.tensorMap=new Map,s(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return He(this.size(),"int32")}async import(t,a){this.checkKeyAndValueTensor(t,a);const n=await t.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),m((()=>{const t=i(a),r=n.length,o=t.length;e.assert(r===o,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${o} elements.`));for(let e=0;e<r;e++){const a=n[e],r=t[e];s(r),this.tensorMap.set(a,r)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const a=await e.data();return m((()=>{const e=[];for(let n=0;n<a.length;n++){const s=a[n],r=this.findWithDefault(s,t);e.push(r)}return o(e)}))}findWithDefault(e,t){const a=this.tensorMap.get(e);return null!=a?a:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}function Ga(t,a,n,s){const r=((t,a,n)=>{switch(t.category){case"arithmetic":return m((()=>((e,t,a)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[w(Zt("a",e,t,a),Zt("b",e,t,a))];case"AddN":return[O(Zt("tensors",e,t,a))];case"FloorMod":case"Mod":return[S(Zt("a",e,t,a),Zt("b",e,t,a))];case"Mul":return[_(Zt("a",e,t,a),Zt("b",e,t,a))];case"RealDiv":case"Div":return[T(Zt("a",e,t,a),Zt("b",e,t,a))];case"DivNoNan":return[x(Zt("a",e,t,a),Zt("b",e,t,a))];case"FloorDiv":return[b(Zt("a",e,t,a),Zt("b",e,t,a))];case"Sub":return[g(Zt("a",e,t,a),Zt("b",e,t,a))];case"Minimum":return[N(Zt("a",e,t,a),Zt("b",e,t,a))];case"Maximum":return[f(Zt("a",e,t,a),Zt("b",e,t,a))];case"Pow":return[h(Zt("a",e,t,a),Zt("b",e,t,a))];case"SquaredDifference":return[l(Zt("a",e,t,a),Zt("b",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"basic_math":return m((()=>((e,t,a)=>{switch(e.op){case"Abs":case"ComplexAbs":return[ye(Zt("x",e,t,a))];case"Acos":return[ce(Zt("x",e,t,a))];case"Acosh":return[de(Zt("x",e,t,a))];case"Asin":return[ue(Zt("x",e,t,a))];case"Asinh":return[me(Zt("x",e,t,a))];case"Atan":return[ie(Zt("x",e,t,a))];case"Atan2":return[pe(Zt("x",e,t,a),Zt("y",e,t,a))];case"Atanh":return[oe(Zt("x",e,t,a))];case"Ceil":return[re(Zt("x",e,t,a))];case"Complex":return[se(Zt("real",e,t,a),Zt("imag",e,t,a))];case"Cos":return[ne(Zt("x",e,t,a))];case"Cosh":return[ae(Zt("x",e,t,a))];case"Elu":return[te(Zt("x",e,t,a))];case"Erf":return[ee(Zt("x",e,t,a))];case"Exp":return[J(Zt("x",e,t,a))];case"Expm1":return[Y(Zt("x",e,t,a))];case"Floor":return[Z(Zt("x",e,t,a))];case"Log":return[X(Zt("x",e,t,a))];case"Log1p":return[K(Zt("x",e,t,a))];case"Imag":return[Q(Zt("x",e,t,a))];case"Neg":return[G(Zt("x",e,t,a))];case"Reciprocal":return[U(Zt("x",e,t,a))];case"Real":return[q(Zt("x",e,t,a))];case"Relu":return[W(Zt("x",e,t,a))];case"Round":return[H(Zt("x",e,t,a))];case"Selu":return[B(Zt("x",e,t,a))];case"Sigmoid":return[P(Zt("x",e,t,a))];case"Sin":return[j(Zt("x",e,t,a))];case"Sign":return[R(Zt("x",e,t,a))];case"Sinh":return[$(Zt("x",e,t,a))];case"Softplus":return[F(Zt("x",e,t,a))];case"Sqrt":return[L(Zt("x",e,t,a))];case"Square":return[C(Zt("x",e,t,a))];case"Tanh":return[z(Zt("x",e,t,a))];case"Tan":return[V(Zt("x",e,t,a))];case"ClipByValue":return[M(Zt("x",e,t,a),Zt("clipValueMin",e,t,a),Zt("clipValueMax",e,t,a))];case"Relu6":return[k(Zt("x",e,t,a))];case"Rsqrt":return[D(Yt(e.inputNames[0],t,a))];case"Prod":return[v(Zt("x",e,t,a),Zt("axes",e,t,a))];case"LeakyRelu":return[I(Zt("x",e,t,a),Zt("alpha",e,t,a))];case"Prelu":return[E(Zt("x",e,t,a),Zt("alpha",e,t,a))];case"IsNan":return[A(Yt(e.inputNames[0],t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"control":return Ha(t,a,n);case"convolution":return m((()=>((e,t,a)=>{switch(e.op){case"Conv1D":{const n=Zt("stride",e,t,a),s=Zt("pad",e,t,a),r=Zt("dataFormat",e,t,a).toUpperCase(),o=Zt("dilation",e,t,a);return[we(Zt("x",e,t,a),Zt("filter",e,t,a),n,s,r,o)]}case"Conv2D":{const n=Zt("strides",e,t,a),s=aa(e,t,a),r=Zt("dataFormat",e,t,a).toUpperCase(),o=Zt("dilations",e,t,a);return[Oe(Zt("x",e,t,a),Zt("filter",e,t,a),[n[1],n[2]],s,r,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:n,pad:s,dataFormat:r,dilations:o,biasArg:p,preluArg:i,activationFunc:m,leakyreluAlpha:u}=Wa(e,t,a);return[Se.conv2d({x:Zt("x",e,t,a),filter:Zt("filter",e,t,a),strides:[n[1],n[2]],pad:s,dataFormat:r,dilations:[o[1],o[2]],bias:p,activation:m,preluActivationWeights:i,leakyreluAlpha:u})]}case"FusedDepthwiseConv2dNative":{const{stride:n,pad:s,dataFormat:r,dilations:o,biasArg:p,preluArg:i,activationFunc:m,leakyreluAlpha:u}=Wa(e,t,a);return[Se.depthwiseConv2d({x:Zt("x",e,t,a),filter:Zt("filter",e,t,a),strides:[n[1],n[2]],pad:s,dataFormat:r,dilations:[o[1],o[2]],bias:p,activation:m,preluActivationWeights:i,leakyreluAlpha:u})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const n=Zt("outputShape",e,t,a),s=Zt("strides",e,t,a),r=aa(e,t,a);return[_e(Zt("x",e,t,a),Zt("filter",e,t,a),n,[s[1],s[2]],r)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const n=Zt("strides",e,t,a),s=aa(e,t,a),r=Zt("dilations",e,t,a),o=Zt("dataFormat",e,t,a).toUpperCase();return[Te(Zt("input",e,t,a),Zt("filter",e,t,a),[n[1],n[2]],s,o,[r[1],r[2]])]}case"Conv3D":{const n=Zt("strides",e,t,a),s=Zt("pad",e,t,a),r=Zt("dataFormat",e,t,a).toUpperCase(),o=Zt("dilations",e,t,a);return[xe(Zt("x",e,t,a),Zt("filter",e,t,a),[n[1],n[2],n[3]],s,r,[o[1],o[2],o[3]])]}case"AvgPool":{const n=Zt("strides",e,t,a),s=Zt("pad",e,t,a),r=Zt("kernelSize",e,t,a);return[be(Zt("x",e,t,a),[r[1],r[2]],[n[1],n[2]],s)]}case"MaxPool":{const n=Zt("strides",e,t,a),s=Zt("pad",e,t,a),r=Zt("kernelSize",e,t,a);return[ge(Zt("x",e,t,a),[r[1],r[2]],[n[1],n[2]],s)]}case"MaxPoolWithArgmax":{const n=Zt("strides",e,t,a),s=Zt("pad",e,t,a),r=Zt("kernelSize",e,t,a),o=Zt("includeBatchInIndex",e,t,a),{result:p,indexes:i}=Ne(Zt("x",e,t,a),[r[1],r[2]],[n[1],n[2]],s,o);return[p,i]}case"AvgPool3D":{const n=Zt("strides",e,t,a),s=Zt("pad",e,t,a),r=Zt("kernelSize",e,t,a);return[fe(Zt("x",e,t,a),[r[1],r[2],r[3]],[n[1],n[2],n[3]],s)]}case"MaxPool3D":{const n=Zt("strides",e,t,a),s=Zt("pad",e,t,a),r=Zt("kernelSize",e,t,a);return[he(Zt("x",e,t,a),[r[1],r[2],r[3]],[n[1],n[2],n[3]],s)]}case"Dilation2D":{const n=Zt("strides",e,t,a),s=Zt("pad",e,t,a),r=Zt("dilations",e,t,a),o=n[1],p=n[2],i=r[1],m=r[2];return[le(Zt("x",e,t,a),Zt("filter",e,t,a),[o,p],s,[i,m],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"creation":return m((()=>((e,t,a)=>{switch(e.op){case"Fill":{const n=Zt("shape",e,t,a),s=Zt("dtype",e,t,a),r=Zt("value",e,t,a);return[Le(n,r,s)]}case"LinSpace":{const n=Zt("start",e,t,a),s=Zt("stop",e,t,a),r=Zt("num",e,t,a);return[Ce(n,s,r)]}case"Multinomial":{const n=Zt("logits",e,t,a),s=Zt("numSamples",e,t,a),r=Zt("seed",e,t,a);return[ze(n,s,r)]}case"OneHot":{const n=Zt("indices",e,t,a),s=Zt("depth",e,t,a),r=Zt("onValue",e,t,a),o=Zt("offValue",e,t,a);return[Ve(n,s,r,o)]}case"Ones":return[Me(Zt("shape",e,t,a),Zt("dtype",e,t,a))];case"OnesLike":return[ke(Zt("x",e,t,a))];case"RandomUniform":return[De(Zt("shape",e,t,a),Zt("minval",e,t,a),Zt("maxval",e,t,a),Zt("dtype",e,t,a))];case"Range":{const n=Zt("start",e,t,a),s=Zt("stop",e,t,a),r=Zt("step",e,t,a);return[ve(n,s,r,Zt("dtype",e,t,a))]}case"TruncatedNormal":{const n=Zt("shape",e,t,a),s=Zt("mean",e,t,a),r=Zt("stdDev",e,t,a),o=Zt("seed",e,t,a);return[Ie(n,s,r,Zt("dtype",e,t,a),o)]}case"Zeros":return[Ee(Zt("shape",e,t,a),Zt("dtype",e,t,a))];case"ZerosLike":return[Ae(Zt("x",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"dynamic":return(async(e,t,a)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:o,scoreThreshold:p,softNmsSigma:i}=qa(e,t,a),m=await je.nonMaxSuppressionWithScoreAsync(n,s,r,o,p,i);return[m.selectedIndices,m.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:o,scoreThreshold:p}=qa(e,t,a),i=Zt("padToMaxOutputSize",e,t,a),m=await je.nonMaxSuppressionPaddedAsync(n,s,r,o,p,i);return[m.selectedIndices,m.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:o,scoreThreshold:p}=qa(e,t,a);return[await je.nonMaxSuppressionAsync(n,s,r,o,p)]}case"Where":{const n=$e(Zt("condition",e,t,a),"bool"),s=[await Re(n)];return n.dispose(),s}case"ListDiff":return Fe(Zt("x",e,t,a),Zt("y",e,t,a));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n);case"evaluation":return m((()=>((e,t,a)=>{switch(e.op){case"TopKV2":{const n=Zt("x",e,t,a),s=Zt("k",e,t,a),r=Zt("sorted",e,t,a),o=Be(n,s,r);return[o.values,o.indices]}case"Unique":{const n=Zt("x",e,t,a),s=Pe(n);return[s.values,s.indices]}case"UniqueV2":{const n=Zt("x",e,t,a),s=Zt("axis",e,t,a),r=Pe(n,s);return[r.values,r.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"image":return m((()=>((e,t,a)=>{switch(e.op){case"ResizeBilinear":{const n=Zt("images",e,t,a),s=Zt("size",e,t,a),r=Zt("alignCorners",e,t,a),o=Zt("halfPixelCenters",e,t,a);return[je.resizeBilinear(n,[s[0],s[1]],r,o)]}case"ResizeNearestNeighbor":{const n=Zt("images",e,t,a),s=Zt("size",e,t,a),r=Zt("alignCorners",e,t,a),o=Zt("halfPixelCenters",e,t,a);return[je.resizeNearestNeighbor(n,[s[0],s[1]],r,o)]}case"CropAndResize":{const n=Zt("image",e,t,a),s=Zt("boxes",e,t,a),r=Zt("boxInd",e,t,a),o=Zt("cropSize",e,t,a),p=Zt("method",e,t,a),i=Zt("extrapolationValue",e,t,a);return[je.cropAndResize(n,s,r,o,p,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"graph":return m((()=>((e,t,a)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const n=Zt("default",e,t,a);return[Yt(e.name,t,a)||n];case"Placeholder":return[Yt(e.name,t,a)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[na(Zt("x",e,t,a))];case"IdentityN":return Zt("x",e,t,a).map((e=>na(e)));case"Snapshot":return[na(Zt("x",e,t,a))];case"Shape":return[We(Zt("x",e,t,a).shape,"int32")];case"ShapeN":return Zt("x",e,t,a).map((e=>We(e.shape)));case"Size":return[He(Zt("x",e,t,a).size,"int32")];case"Rank":return[He(Zt("x",e,t,a).rank,"int32")];case"NoOp":return[He(1)];case"Print":const s=Zt("x",e,t,a),r=Zt("data",e,t,a),o=Zt("message",e,t,a),p=Zt("summarize",e,t,a);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<r.length;e++)console.log(Array.prototype.slice.call(r[e].dataSync()).slice(0,p));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"logical":return m((()=>((e,t,a)=>{switch(e.op){case"Equal":return[et(Zt("a",e,t,a),Zt("b",e,t,a))];case"NotEqual":return[Je(Zt("a",e,t,a),Zt("b",e,t,a))];case"Greater":return[Ye(Zt("a",e,t,a),Zt("b",e,t,a))];case"GreaterEqual":return[Ze(Zt("a",e,t,a),Zt("b",e,t,a))];case"Less":return[Xe(Zt("a",e,t,a),Zt("b",e,t,a))];case"LessEqual":return[Ke(Zt("a",e,t,a),Zt("b",e,t,a))];case"LogicalAnd":return[Qe(Zt("a",e,t,a),Zt("b",e,t,a))];case"LogicalNot":return[Ge(Zt("a",e,t,a))];case"LogicalOr":return[Ue(Zt("a",e,t,a),Zt("b",e,t,a))];case"Select":case"SelectV2":return[qe(Zt("condition",e,t,a),Zt("a",e,t,a),Zt("b",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"matrices":return m((()=>((e,t,a)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[nt(Zt("a",e,t,a),Zt("b",e,t,a),Zt("transposeA",e,t,a),Zt("transposeB",e,t,a))];case"Einsum":return[at(Zt("equation",e,t,a),...Zt("tensors",e,t,a))];case"Transpose":return[tt(Zt("x",e,t,a),Zt("perm",e,t,a))];case"_FusedMatMul":const[n,s]=Zt("fusedOps",e,t,a),r="biasadd"===n,o="prelu"===s,p=Zt("numArgs",e,t,a),i=Zt("leakyreluAlpha",e,t,a);if(r){if(o&&2!==p)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==p)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[m,u]=Zt("args",e,t,a);return[Se.matMul({a:Zt("a",e,t,a),b:Zt("b",e,t,a),transposeA:Zt("transposeA",e,t,a),transposeB:Zt("transposeB",e,t,a),bias:m,activation:s,preluActivationWeights:u,leakyreluAlpha:i})];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"normalization":return m((()=>((e,t,a)=>{switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[it(Zt("x",e,t,a),Zt("mean",e,t,a),Zt("variance",e,t,a),Zt("offset",e,t,a),Zt("scale",e,t,a),Zt("epsilon",e,t,a))];case"LRN":return[pt(Zt("x",e,t,a),Zt("radius",e,t,a),Zt("bias",e,t,a),Zt("alpha",e,t,a),Zt("beta",e,t,a))];case"Softmax":return[ot(Zt("x",e,t,a))];case"LogSoftmax":return[rt(Zt("x",e,t,a))];case"SparseToDense":return[st(Zt("sparseIndices",e,t,a),Zt("outputShape",e,t,a),Zt("sparseValues",e,t,a),Zt("defaultValue",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"reduction":return m((()=>((e,t,a)=>{switch(e.op){case"Max":{const n=Zt("axis",e,t,a),s=Zt("keepDims",e,t,a);return[bt(Zt("x",e,t,a),n,s)]}case"Mean":{const n=Zt("axis",e,t,a),s=Zt("keepDims",e,t,a);return[gt(Zt("x",e,t,a),n,s)]}case"Min":{const n=Zt("axis",e,t,a),s=Zt("keepDims",e,t,a);return[Nt(Zt("x",e,t,a),n,s)]}case"Sum":{const n=Zt("axis",e,t,a),s=Zt("keepDims",e,t,a);return[ft(Zt("x",e,t,a),n,s)]}case"All":{const n=Zt("axis",e,t,a),s=Zt("keepDims",e,t,a);return[ht(Zt("x",e,t,a),n,s)]}case"Any":{const n=Zt("axis",e,t,a),s=Zt("keepDims",e,t,a);return[lt(Zt("x",e,t,a),n,s)]}case"ArgMax":{const n=Zt("axis",e,t,a);return[yt(Zt("x",e,t,a),n)]}case"ArgMin":{const n=Zt("axis",e,t,a);return[ct(Zt("x",e,t,a),n)]}case"Prod":{const n=Zt("axis",e,t,a),s=Zt("keepDims",e,t,a);return[v(Zt("x",e,t,a),n,s)]}case"Cumsum":{const n=Zt("axis",e,t,a),s=Zt("exclusive",e,t,a),r=Zt("reverse",e,t,a);return[dt(Zt("x",e,t,a),n,s,r)]}case"Bincount":const n=Zt("x",e,t,a),s=Zt("weights",e,t,a),r=Zt("size",e,t,a);return[ut(n,s,r)];case"DenseBincount":{const n=Zt("x",e,t,a),s=Zt("weights",e,t,a),r=Zt("size",e,t,a),o=Zt("binaryOutput",e,t,a);return[mt(n,s,r,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"slice_join":return m((()=>((t,a,n)=>{switch(t.op){case"ConcatV2":case"Concat":{const e=Zt("n",t,a,n),s=Zt("axis",t,a,n);let r=Zt("tensors",t,a,n);return r=r.slice(0,e),[Mt(r,s)]}case"Gather":{const e=Zt("x",t,a,n),s=Zt("indices",t,a,n);return[kt(e,$e(s,"int32"),0)]}case"GatherV2":{const e=Zt("axis",t,a,n),s=Zt("batchDims",t,a,n),r=Zt("x",t,a,n),o=Zt("indices",t,a,n);return[kt(r,$e(o,"int32"),e,s)]}case"Reverse":{const e=Zt("dims",t,a,n),s=[];for(let t=0;t<e.length;t++)e[t]&&s.push(t);const r=Zt("x",t,a,n);return[Dt(r,s)]}case"ReverseV2":{const e=Zt("axis",t,a,n),s=Zt("x",t,a,n);return[Dt(s,e)]}case"Slice":{const e=Zt("begin",t,a,n),s=Zt("size",t,a,n);return[vt(Zt("x",t,a,n),e,s)]}case"StridedSlice":{const e=Zt("begin",t,a,n),s=Zt("end",t,a,n),r=Zt("strides",t,a,n),o=Zt("beginMask",t,a,n),p=Zt("endMask",t,a,n),i=Zt("ellipsisMask",t,a,n),m=Zt("newAxisMask",t,a,n),u=Zt("shrinkAxisMask",t,a,n),d=Zt("x",t,a,n);return[It(d,e,s,r,o,p,i,m,u)]}case"Pack":return m((()=>{const s=Zt("axis",t,a,n),r=Zt("tensors",t,a,n),o=r[0].shape,p=wt(r[0]).shape,i=r.map((t=>{const a=e.arraysEqual(t.shape,o);if(!a&&!e.arraysEqual(wt(t).shape,p))throw new Error("the input tensors shape does not match");return a?t:At(t,o)}));return[Et(i,s)]}));case"Unpack":{const e=Zt("axis",t,a,n),s=Zt("tensor",t,a,n);return Ot(s,e)}case"Tile":{const e=Zt("reps",t,a,n);return[St(Zt("x",t,a,n),e)]}case"Split":case"SplitV":{const e=Zt("axis",t,a,n),s=Zt("numOrSizeSplits",t,a,n),r=Zt("x",t,a,n);return _t(r,s,e)}case"ScatterNd":{const e=Zt("indices",t,a,n),s=Zt("values",t,a,n),r=Zt("shape",t,a,n);return[Tt(e,s,r)]}case"GatherNd":{const e=Zt("x",t,a,n),s=Zt("indices",t,a,n);return[xt(e,s)]}case"SparseToDense":{const e=Zt("sparseIndices",t,a,n),s=Zt("outputShape",t,a,n),r=Zt("sparseValues",t,a,n),o=Zt("defaultValue",t,a,n);return[st(e,r,s,r.dtype===o.dtype?o:$e(o,r.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,a,n)));case"sparse":return m((()=>((e,t,a)=>{switch(e.op){case"SparseReshape":{const{outputIndices:n,outputShape:s}=Vt.sparseReshape(Zt("inputIndices",e,t,a),Zt("inputShape",e,t,a),Zt("newShape",e,t,a));return[n,s]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"spectral":return m((()=>((e,t,a)=>{switch(e.op){case"FFT":return[Ft(Zt("x",e,t,a))];case"IFFT":return[Lt(Zt("x",e,t,a))];case"RFFT":return[Ct(Zt("x",e,t,a))];case"IRFFT":return[zt(Zt("x",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"transformation":return m((()=>((e,t,a)=>{switch(e.op){case"Cast":return[$e(Zt("x",e,t,a),Zt("dtype",e,t,a))];case"ExpandDims":{const n=Zt("axis",e,t,a);return[Wt(Zt("x",e,t,a),n)]}case"Squeeze":{const n=Zt("axis",e,t,a);return[wt(Zt("x",e,t,a),n)]}case"Reshape":return[At(Zt("x",e,t,a),Zt("shape",e,t,a))];case"MirrorPad":return[Ht(Zt("x",e,t,a),Zt("padding",e,t,a),Zt("mode",e,t,a))];case"PadV2":case"Pad":return[Bt(Zt("x",e,t,a),Zt("padding",e,t,a),Zt("constantValue",e,t,a))];case"SpaceToBatchND":{const n=Zt("blockShape",e,t,a),s=Zt("paddings",e,t,a);return[Pt(Zt("x",e,t,a),n,s)]}case"BatchToSpaceND":{const n=Zt("blockShape",e,t,a),s=Zt("crops",e,t,a);return[jt(Zt("x",e,t,a),n,s)]}case"DepthToSpace":{const n=Zt("blockSize",e,t,a),s=Zt("dataFormat",e,t,a).toUpperCase();return[Rt(Zt("x",e,t,a),n,s)]}case"BroadcastTo":return[$t(Zt("x",e,t,a),Zt("shape",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n)));case"hash_table":return(async(e,t,a,n)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=Zt("keyDType",e,t,a),r=Zt("valueDType",e,t,a),o=new Ua(s,r);return n.addHashTable(e.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=Zt("tableHandle",e,t,a,n),r=Zt("keys",e,t,a),o=Zt("values",e,t,a),p=n.getHashTableById(s.id);return[await p.import(r,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=Zt("tableHandle",e,t,a,n),r=Zt("keys",e,t,a),o=Zt("defaultValue",e,t,a),p=n.getHashTableById(s.id);return[await p.find(r,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=Zt("tableHandle",e,t,a,n);return[n.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(t,a,n,s);case"custom":const r=Kt(t.op);if(r&&r.customExecutor)return r.customExecutor(new La(t,a,n));throw TypeError(`Custom op ${t.op} is not registered.`);default:throw TypeError(`Unknown op '${t.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,a,n);return e.isPromise(r)?r.then((e=>[].concat(e))):[].concat(r)}class Qa{constructor(e={},t={},a={},n={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=a,this.functionMap=n,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const a=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(a))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function Ka(e,t,a,n){const s=new Set,r=[];let o=null,p=null;const i=new Set,m=Object.keys(e).map((e=>ta(e)[0]));let u=[];null!=n&&(u=n.map((e=>ta(e.name)[0])));const d=[...t];for(;d.length>0;){const e=d.pop();(Ja(e)||en(e)||tn(e))&&null==o&&(o=e,p=o.children.map((e=>e.name)).filter((e=>s.has(e)))),s.add(e.name),null==a[e.name]&&(-1===m.indexOf(e.name)&&-1===u.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach((e=>{i.has(e.name)||(i.add(e.name),d.push(e))})):r.push(e.name)))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:r,dynamicNode:o,syncInputs:p}}const Xa=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Za=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Ya=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Ja(e){return Xa.indexOf(e.op)>=0}function en(e){return Za.indexOf(e.op)>=0}function tn(e){return Ya.indexOf(e.op)>=0}class an{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new an(e.functions[t],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}getCompilationKey(e,t){const a=e.map((e=>e.name)).sort(),n=t.map((e=>e.name)).sort();return a.join(this.SEPERATOR)+"--"+n.join(this.SEPERATOR)}compile(e,t){const a=Ka(e,t,this.weightMap,this._initNodes),{missingInputs:n,dynamicNode:s,syncInputs:r}=a;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${r}]`);if(n.length>0){const a=t.map((e=>e.name)),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${s}]. Missing the following inputs: [${n}]`)}return function(e,t,a){const{usedNodes:n,inputs:s}=a,r=[],o=Object.keys(s).map((e=>ta(e)[0])).map((t=>e.nodes[t])),p=e.initNodes;o.forEach((e=>{n.has(e.name)&&r.push(e)})),e.weights.forEach((e=>{n.has(e.name)&&r.push(e)})),null!=p&&p.forEach((e=>{n.has(e.name)&&r.push(e)}));const i=new Set,m=[];for(;r.length>0;){const e=r.pop();i.add(e.name),t[e.name]||m.push(e),e.children.forEach((e=>{!i.has(e.name)&&n.has(e.name)&&e.inputs.every((e=>i.has(e.name)))&&r.push(e)}))}return m}(this.graph,this.weightMap,a)}execute(t,a){t=this.mapInputs(t);const n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),a=this.mapOutputs(a),this.checkOutputs(a);const s=n.map((e=>this.graph.nodes[ta(e)[0]])),r=a.map((e=>ta(e)[0]));let o=r.map((e=>this.graph.nodes[e]));0===o.length&&(o=this._outputs);const p=this.getCompilationKey(s,o);let i=this.compiledMap.get(p);null==i&&(i=this.compile(t,o),this.compiledMap.set(p,i));const u={},d={};return m((()=>{const n=new Qa(this.weightMap,u,d,this.functionExecutorMap),s=Object.assign({},this.weightMap);Object.keys(t).forEach((e=>{const[a,n]=ta(e),r=[];r[n]=t[e],s[a]=r}));const o=this.getFrozenTensorIds(s),p={};for(let t=0;t<i.length;t++){const a=i[t];if(!s[a.name]){const t=Ga(a,s,n,this._resourceManager);if(e.isPromise(t))throw new Error(`The execution of the op '${a.op}' returned a promise. Please use model.executeAsync() instead.`);s[a.name]=t,this.checkTensorForDisposal(a.name,a,s,n,o,r,p)}}return null==this.parent&&n.dispose(o),a.map((e=>Yt(e,s,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,a,n,s,r,o){"control"!==t.category&&-1===r.indexOf(e)&&(a[e].forEach((e=>{null!=e&&(o[e.id]=(o[e.id]||0)+t.children.length)})),t.inputs.forEach((e=>{if("control"!==e.category){const t=function(e,t,a){return t[ea(e,a.currentContextId)]}(e.name,a,n);null!=t&&t.forEach((e=>{if(e&&!e.kept&&!s.has(e.id)){const t=o[e.id];1===t?(e.dispose(),delete o[e.id]):null!=t&&o[e.id]--}}))}})))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,a=!1,n={},s={}){a||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));const r=new Qa(this.weightMap,n,s,this.functionExecutorMap),o=await this.executeWithControlFlow(e,r,t,a),p=t.map((e=>Yt(e,o,r))),i=p.map((e=>e.id)),m=Object.keys(e).map((t=>e[t].id)),u=new Set([...i,...m,...this.weightIds]);return Object.keys(o).forEach((e=>{o[e].forEach((e=>{!e||e.kept||e.isDisposed||u.has(e.id)||e.dispose()}))})),null==this.parent&&r.dispose(u),p}async executeFunctionAsync(e,t,a){const n=e.reduce(((e,t,a)=>(e[this.inputs[a].name]=t,e)),{});return this._executeAsync(n,this.outputNodes,!0,t,a)}async executeWithControlFlow(e,t,a,n){const s=Object.keys(e),r=s.map((e=>this.graph.nodes[ta(e)[0]])),o=a.map((e=>ta(e)[0]));let p=o.map((e=>this.graph.nodes[e]));0===p.length&&(p=this._outputs);const{usedNodes:i,missingInputs:m,dynamicNode:u,syncInputs:d}=Ka(e,p,this.weightMap,this._initNodes),c=[...r,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),y=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[a,n]=ta(t),s=[];s[n]=e[t],y[a]=s}));const l={},h=this.getFrozenTensorIds(y),f={};for(;c.length>0;){const e=this.processStack(r,c,t,y,f,h,o,l,i);await Promise.all(e)}null!=u||n||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const N=p.filter((e=>!Ja(e)&&!Yt(e.name,y,t))).map((e=>e.name));if(N.length>0){let e="";throw null!=u&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${N}] from the provided inputs [${s}]. Consider providing the following inputs: [${m}]. ${e}`)}return y}processStack(t,a,n,s,r,o,p,i,m){const u=[];for(;a.length>0;){const t=a.pop();n.currentContext=t.contexts;let d="";if("Enter"===t.node.op&&Zt("isConstant",t.node,s,n)&&([d]=Jt(t.node.name,n)),null==s[t.node.name]){const c=Ga(t.node,s,n,this._resourceManager);d||([d]=Jt(t.node.name,n));const y=n.currentContext;e.isPromise(c)?u.push(c.then((e=>(s[d]=e,n.currentContext=y,this.checkTensorForDisposal(d,t.node,s,n,o,p,i),this.processChildNodes(t.node,a,n,s,r,m),e)))):(s[d]=c,this.checkTensorForDisposal(d,t.node,s,n,o,p,i),this.processChildNodes(t.node,a,n,s,r,m))}else this.processChildNodes(t.node,a,n,s,r,m)}return u}processChildNodes(e,t,a,n,s,r){e.children.forEach((e=>{const[o]=Jt(e.name,a);!s[o]&&r.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!Yt(e,n,a)))&&(s[o]=!0,t.push({contexts:a.currentContext,node:e})):e.inputNames.every((e=>!!Yt(e,n,a)))&&(s[o]=!0,t.push({contexts:a.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(t){Object.keys(t).forEach((a=>{const n=t[a],[s]=ta(a),r=this.graph.nodes[s];if(r.attrParams.shape&&r.attrParams.shape.value){const t=r.attrParams.shape.value,a=t.length===n.shape.length&&n.shape.every(((e,a)=>-1===t[a]||t[a]===e));e.assert(a,(()=>`The shape of dict['${r.name}'] provided in model.execute(dict) must be [${t}], but was [${n.shape}]`))}r.attrParams.dtype&&r.attrParams.dtype.value&&e.assert(n.dtype===r.attrParams.dtype.value,(()=>`The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){const t={};for(const a in e)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[a]){t[this._signature.inputs[a].name]=e[a]}else t[a]=e[a];return t}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=ta(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]){return this._signature.outputs[e].name}return e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=ta(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class nn{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}class sn{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={}),this.resourceManager=new nn}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=c.browserHTTPRequest(e,this.loadOptions);else{const t=c.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(c.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let a;a=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=a,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const n=c.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new an(Ta.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=Ta.Instance.transformGraph(e.modelInitializer);this.initializer=new an(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"==typeof e){const t=c.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof y||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce(((t,a,n)=>(t[a]=e[n],t)),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const a=this.executor.execute(e,t);return a.length>1?a:a[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const a=await this.executor.executeAsync(e,t);return a.length>1?a:a[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,a)=>(t[a]=[e[a]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function rn(e,t={}){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&null==e.load&&(e.endsWith("/")||(e+="/"),e=`${e}model.json?tfjs-format=file`);const a=new sn(e,t);return await a.load(),a}const on="3.6.0";export{sn as GraphModel,Xt as deregisterOp,rn as loadGraphModel,Qt as registerOp,on as version_converter};
//# sourceMappingURL=tf-converter.fesm.min.js.map
