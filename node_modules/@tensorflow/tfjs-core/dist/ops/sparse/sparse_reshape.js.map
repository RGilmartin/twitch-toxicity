{"version":3,"file":"sparse_reshape.js","sourceRoot":"","sources":["../../../src/ops/sparse/sparse_reshape.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;GAeG;AAEH,OAAO,EAAC,MAAM,EAAC,MAAM,cAAc,CAAC;AACpC,OAAO,EAAC,aAAa,EAAsB,MAAM,oBAAoB,CAAC;AAGtE,OAAO,EAAC,eAAe,EAAC,MAAM,uBAAuB,CAAC;AAEtD,OAAO,EAAC,EAAE,EAAC,MAAM,cAAc,CAAC;AAEhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAiCG;AACH,SAAS,cAAc,CACnB,YAAiC,EAAE,UAA+B,EAClE,QAA6B;IAC/B,MAAM,aAAa,GACf,eAAe,CAAC,YAAY,EAAE,cAAc,EAAE,eAAe,CAAC,CAAC;IACnE,MAAM,WAAW,GACb,eAAe,CAAC,UAAU,EAAE,YAAY,EAAE,eAAe,CAAC,CAAC;IAC/D,MAAM,SAAS,GAAG,eAAe,CAAC,QAAQ,EAAE,UAAU,EAAE,eAAe,CAAC,CAAC;IAEzE,IAAI,aAAa,CAAC,IAAI,KAAK,CAAC,EAAE;QAC5B,MAAM,IAAI,KAAK,CAAC;UACV,aAAa,CAAC,KAAK,EAAE,CAAC,CAAC;KAC9B;IACD,IAAI,WAAW,CAAC,IAAI,KAAK,CAAC,EAAE;QAC1B,MAAM,IAAI,KAAK,CAAC,qDACZ,WAAW,CAAC,KAAK,EAAE,CAAC,CAAC;KAC1B;IACD,IAAI,SAAS,CAAC,IAAI,KAAK,CAAC,EAAE;QACxB,MAAM,IAAI,KAAK,CACX,mDAAmD,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC;KAC3E;IAED,MAAM,MAAM,GAAwB;QAClC,YAAY,EAAE,aAAa;QAC3B,UAAU,EAAE,WAAW;QACvB,QAAQ,EAAE,SAAS;KACpB,CAAC;IACF,MAAM,MAAM,GAAa,MAAM,CAAC,SAAS,CAAC,aAAa,EAAE,MAAY,CAAC,CAAC;IACvE,OAAO,EAAC,aAAa,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,WAAW,EAAE,MAAM,CAAC,CAAC,CAAC,EAAC,CAAC;AAC5D,CAAC;AAED,MAAM,CAAC,MAAM,aAAa,GAAG,EAAE,CAAC,EAAC,cAAc,EAAC,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {SparseReshape, SparseReshapeInputs} from '../../kernel_names';\nimport {Tensor, Tensor1D, Tensor2D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {op} from '../operation';\n\n/**\n * This operation has the same semantics as reshape on the represented dense\n * tensor. The `inputIndices` are recomputed based on the requested `newShape`.\n * If one component of `newShape` is the special value -1, the size of that\n * dimension is computed so that the total dense size remains constant. At most\n * one component of `newShape` can be -1. The number of dense elements implied\n * by `newShape` must be the same as the number of dense elements originally\n * implied by `inputShape`. Reshaping does not affect the order of values in the\n * SparseTensor. If the input tensor has rank R_in and N non-empty values, and\n * `newShape` has length R_out, then `inputIndices` has shape [N, R_in],\n * `inputShape` has length R_in, `outputIndices` has shape [N, R_out], and\n * `outputShape` has length R_out.\n *\n * ```js\n * const result = tf.sparse.sparseReshape(\n *   [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]],\n *   [2, 3, 6], [9, -1]);\n * console.log(result);\n * result['outputIndices'].print(); //[[0, 0], [0, 1], [1, 2], [4, 2], [8, 1]]\n * result['outputShape'].print(); // [9, 4]\n * ```\n * @param inputIndices: 2-D. N x R_in matrix with the indices of non-empty\n * values in a SparseTensor.\n * @param inputShape: 1-D. R_in Tensor1D with the input SparseTensor's dense\n * shape.\n * @param newShape: 1-D. R_out Tensor1D with the requested new dense shape.\n * @return A map with the following properties:\n *     - outputIndices: 2-D. N x R_out matrix with the updated indices of\n *       non-empty values in the output SparseTensor.\n *     - outputShape: 1-D. R_out vector with the full dense shape of the output\n *       SparseTensor. This is the same as newShape but with any -1 dimensions\n *        filled in.\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\nfunction sparseReshape_(\n    inputIndices: Tensor2D|TensorLike, inputShape: Tensor1D|TensorLike,\n    newShape: Tensor1D|TensorLike): NamedTensorMap {\n  const $inputIndices =\n      convertToTensor(inputIndices, 'inputIndices', 'sparseReshape');\n  const $inputShape =\n      convertToTensor(inputShape, 'inputShape', 'sparseReshape');\n  const $newShape = convertToTensor(newShape, 'newShape', 'sparseReshape');\n\n  if ($inputIndices.rank !== 2) {\n    throw new Error(`Input indices should be Tensor2D but received shape\n        ${$inputIndices.shape}`);\n  }\n  if ($inputShape.rank !== 1) {\n    throw new Error(`Input shape should be Tensor1D but received shape ${\n        $inputShape.shape}`);\n  }\n  if ($newShape.rank !== 1) {\n    throw new Error(\n        `New shape should be Tensor1D but received shape ${$newShape.shape}`);\n  }\n\n  const inputs: SparseReshapeInputs = {\n    inputIndices: $inputIndices,\n    inputShape: $inputShape,\n    newShape: $newShape\n  };\n  const result: Tensor[] = ENGINE.runKernel(SparseReshape, inputs as {});\n  return {outputIndices: result[0], outputShape: result[1]};\n}\n\nexport const sparseReshape = op({sparseReshape_});\n"]}