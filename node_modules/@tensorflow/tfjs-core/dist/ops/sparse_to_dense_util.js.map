{"version":3,"file":"sparse_to_dense_util.js","sourceRoot":"","sources":["../../src/ops/sparse_to_dense_util.ts"],"names":[],"mappings":"AAkBA;;;;;;;;;;;;GAYG;AACH,MAAM,UAAU,aAAa,CACzB,aAAqB,EAAE,YAAoB,EAAE,WAAqB,EAClE,aAAqB;IACvB,IAAI,aAAa,CAAC,KAAK,KAAK,OAAO,EAAE;QACnC,MAAM,IAAI,KAAK,CACX,0DAA0D;YAC1D,sBAAsB,aAAa,CAAC,KAAK,GAAG,CAAC,CAAC;KACnD;IACD,IAAI,aAAa,CAAC,IAAI,GAAG,CAAC,EAAE;QAC1B,MAAM,IAAI,KAAK,CACX,sDAAsD;YACtD,kBAAkB,aAAa,CAAC,KAAK,GAAG,CAAC,CAAC;KAC/C;IAED,MAAM,QAAQ,GAAG,aAAa,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACrE,MAAM,OAAO,GAAG,aAAa,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAEpE,IAAI,WAAW,CAAC,MAAM,KAAK,OAAO,EAAE;QAClC,MAAM,IAAI,KAAK,CACX,gDAAgD;YAChD,IAAI,WAAW,CAAC,MAAM,gBAAgB,OAAO,GAAG,CAAC,CAAC;KACvD;IAED,MAAM,SAAS,GAAG,YAAY,CAAC,IAAI,CAAC;IACpC,IAAI,CAAC,CAAC,YAAY,CAAC,IAAI,KAAK,CAAC;QACvB,YAAY,CAAC,IAAI,KAAK,CAAC,IAAI,SAAS,KAAK,QAAQ,CAAC,EAAE;QACxD,MAAM,IAAI,KAAK,CACX,mCAAmC;YACnC,GAAG,YAAY,CAAC,KAAK,sBAAsB,QAAQ,GAAG,CAAC,CAAC;KAC7D;IAED,IAAI,YAAY,CAAC,KAAK,KAAK,aAAa,CAAC,KAAK,EAAE;QAC9C,MAAM,IAAI,KAAK,CAAC,mDAAmD,CAAC,CAAC;KACtE;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor} from '../tensor';\n\n/**\n * Validate sparseToDense inputs.\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape number[]. Shape of the dense output tensor.\n * @param validateIndices boolean. indice validation is not supported, error\n * will be thrown if it is set.\n */\nexport function validateInput(\n    sparseIndices: Tensor, sparseValues: Tensor, outputShape: number[],\n    defaultValues: Tensor) {\n  if (sparseIndices.dtype !== 'int32') {\n    throw new Error(\n        'tf.sparseToDense() expects the indices to be int32 type,' +\n        ` but the dtype was ${sparseIndices.dtype}.`);\n  }\n  if (sparseIndices.rank > 2) {\n    throw new Error(\n        'sparseIndices should be a scalar, vector, or matrix,' +\n        ` but got shape ${sparseIndices.shape}.`);\n  }\n\n  const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;\n  const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;\n\n  if (outputShape.length !== numDims) {\n    throw new Error(\n        'outputShape has incorrect number of elements:,' +\n        ` ${outputShape.length}, should be: ${numDims}.`);\n  }\n\n  const numValues = sparseValues.size;\n  if (!(sparseValues.rank === 0 ||\n        sparseValues.rank === 1 && numValues === numElems)) {\n    throw new Error(\n        'sparseValues has incorrect shape ' +\n        `${sparseValues.shape}, should be [] or [${numElems}]`);\n  }\n\n  if (sparseValues.dtype !== defaultValues.dtype) {\n    throw new Error('sparseValues.dtype must match defaultValues.dtype');\n  }\n}\n"]}