{"version":3,"file":"gather_nd_util.js","sourceRoot":"","sources":["../../src/ops/gather_nd_util.ts"],"names":[],"mappings":"AAiBA,OAAO,EAAC,cAAc,EAAE,aAAa,EAAC,MAAM,SAAS,CAAC;AAEtD;;;;;;;GAOG;AACH,MAAM,UAAU,kBAAkB,CAAC,MAAkB,EAAE,OAAmB;IAExE,MAAM,UAAU,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC;IACvC,MAAM,WAAW,GAAG,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC;IACzC,IAAI,UAAU,GAAG,CAAC,EAAE;QAClB,MAAM,IAAI,KAAK,CACX,yDAAyD;YACzD,qBAAqB,UAAU,GAAG,CAAC,CAAC;KACzC;IACD,IAAI,WAAW,GAAG,CAAC,EAAE;QACnB,MAAM,IAAI,KAAK,CACX,2DAA2D;YAC3D,qBAAqB,WAAW,GAAG,CAAC,CAAC;KAC1C;IACD,IAAI,OAAO,CAAC,KAAK,KAAK,OAAO,EAAE;QAC7B,MAAM,IAAI,KAAK,CACX,qDAAqD;YACrD,sBAAsB,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC;KAC7C;IACD,IAAI,OAAO,CAAC,KAAK,CAAC,WAAW,GAAG,CAAC,CAAC,GAAG,UAAU,EAAE;QAC/C,MAAM,IAAI,KAAK,CACX,gEAAgE;YAChE,GAAG,OAAO,CAAC,KAAK,CAAC,WAAW,GAAG,CAAC,CAAC,QAAQ,UAAU,EAAE,CAAC,CAAC;KAC5D;IAED,IAAI,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;QACrC,MAAM,IAAI,KAAK,CACX,oDAAoD;YACpD,iBAAiB,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC;KACvC;IAED,MAAM,YAAY,GAAG,OAAO,CAAC,KAAK,CAAC;IACnC,MAAM,SAAS,GAAG,YAAY,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAExD,sBAAsB;IACtB,0DAA0D;IAC1D,IAAI,OAAO,GAAG,CAAC,CAAC;IAChB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;QAChD,OAAO,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC;KAC5B;IAED,MAAM,UAAU,GAAG,MAAM,CAAC,KAAK,CAAC;IAEhC,MAAM,WAAW,GAAG,YAAY,CAAC,KAAK,EAAE,CAAC;IACzC,WAAW,CAAC,GAAG,EAAE,CAAC;IAElB,IAAI,SAAS,GAAG,CAAC,CAAC;IAClB,KAAK,IAAI,CAAC,GAAG,SAAS,EAAE,CAAC,GAAG,UAAU,EAAE,EAAE,CAAC,EAAE;QAC3C,SAAS,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;QAC3B,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;KACjC;IAED,MAAM,OAAO,GACT,CAAC,GAAG,cAAc,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,GAAG,SAAS,CAAC;QACjE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;IAE5B,OAAO,CAAC,WAAW,EAAE,OAAO,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;AACpD,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {TensorInfo} from '../kernel_registry';\nimport {computeStrides, sizeFromShape} from '../util';\n\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\nexport function prepareAndValidate(tensor: TensorInfo, indices: TensorInfo):\n    [number[], number, number, number[]] {\n  const tensorRank = tensor.shape.length;\n  const indicesRank = indices.shape.length;\n  if (tensorRank < 1) {\n    throw new Error(\n        'tf.gatherND() expects the input to be rank 1 or higher,' +\n        ` but the rank was ${tensorRank}.`);\n  }\n  if (indicesRank < 1) {\n    throw new Error(\n        'tf.gatherND() expects the indices to be rank 1 or higher,' +\n        ` but the rank was ${indicesRank}.`);\n  }\n  if (indices.dtype !== 'int32') {\n    throw new Error(\n        'tf.gatherND() expects the indices to be int32 type,' +\n        ` but the dtype was ${indices.dtype}.`);\n  }\n  if (indices.shape[indicesRank - 1] > tensorRank) {\n    throw new Error(\n        'index innermost dimension length must be <= tensor rank; saw: ' +\n        `${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);\n  }\n\n  if (sizeFromShape(tensor.shape) === 0) {\n    throw new Error(\n        'Requested more than 0 entries, but input is empty.' +\n        ` Input shape: ${tensor.shape}.`);\n  }\n\n  const indicesShape = indices.shape;\n  const sliceRank = indicesShape[indicesShape.length - 1];\n\n  // The result shape is\n  //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n  let nResult = 1;\n  for (let i = 0; i < indicesShape.length - 1; ++i) {\n    nResult *= indicesShape[i];\n  }\n\n  const inputShape = tensor.shape;\n\n  const resultShape = indicesShape.slice();\n  resultShape.pop();\n\n  let sliceSize = 1;\n  for (let i = sliceRank; i < tensorRank; ++i) {\n    sliceSize *= inputShape[i];\n    resultShape.push(inputShape[i]);\n  }\n\n  const strides =\n      [...computeStrides(tensor.shape).map(stride => stride / sliceSize),\n       1].slice(0, sliceRank);\n\n  return [resultShape, nResult, sliceSize, strides];\n}\n"]}