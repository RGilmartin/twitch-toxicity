{"version":3,"file":"slice_util.js","sourceRoot":"","sources":["../../src/ops/slice_util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo} from '../kernel_registry';\nimport * as util from '../util';\n\nexport type SliceInfo = {\n  nonStrided: boolean,\n  $begin: number[],\n  $end: number[],\n  $strides: number[],\n  size: number[],\n  newShape: number[],\n  outShape: number[]\n};\n\nexport function assertParamsValid(\n    input: TensorInfo, begin: number[], size: number[]): void {\n  const inputRank = input.shape.length;\n  util.assert(\n      inputRank === begin.length,\n      () => `Error in slice${inputRank}D: Length of begin ${begin} must ` +\n          `match the rank of the array (${inputRank}).`);\n  util.assert(\n      inputRank === size.length,\n      () => `Error in slice${inputRank}D: Length of size ${size} must ` +\n          `match the rank of the array (${inputRank}).`);\n\n  for (let i = 0; i < inputRank; ++i) {\n    util.assert(\n        begin[i] + size[i] <= input.shape[i],\n        () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` +\n            `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${\n                  input.shape[i]})`);\n  }\n}\n\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\nexport function maskToAxes(mask: number): number[] {\n  const axes = [];\n  let axis = 0;\n  while (mask > 0) {\n    if (mask & 1) {\n      axes.push(axis);\n    }\n    mask /= 2;\n    axis++;\n  }\n  return axes;\n}\n\n/** Computes the output shape given the strided slice params. */\nexport function computeOutShape(\n    begin: number[], end: number[], strides: number[]): number[] {\n  const size = [];\n  for (let axis = 0; axis < begin.length; axis++) {\n    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n  }\n  return size;\n}\n\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\nexport function stridesWithElidedDims(\n    strides: number[], ellipsisInsertionIndex: number, numElidedAxes: number,\n    inputShape: number[]): number[] {\n  const newStrides = [...strides];\n  for (let i = newStrides.length; i < inputShape.length; i++) {\n    newStrides.push(1);\n  }\n  for (let i = 0; i < numElidedAxes; i++) {\n    if (i === 0) {\n      newStrides[ellipsisInsertionIndex] = 1;\n    } else {\n      newStrides.splice(\n          ellipsisInsertionIndex, 0 /* num elements to delete */,\n          1 /* element to add */);\n      newStrides.pop();\n    }\n  }\n  return newStrides;\n}\n\nfunction unnormalizeAxis(\n    ellipsisInsertionIndex: number, numElidedAxes: number,\n    normalizedAxis: number): number {\n  if (normalizedAxis <= ellipsisInsertionIndex) {\n    return normalizedAxis;\n  }\n\n  return normalizedAxis - (numElidedAxes - 1);\n}\n\nfunction getElidedAxes(numElidedAxes: number, ellipsisInsertionIndex: number) {\n  const elidedAxes = [];\n  for (let i = 0; i < numElidedAxes; i++) {\n    elidedAxes.push(ellipsisInsertionIndex + i);\n  }\n  return elidedAxes;\n}\n\n// Normalize the start, end and strides.\nexport function getNormalizedAxes(\n    inputShape: number[], ellipsisAxes: number[], numInterpolatedAxes: number,\n    begin: number[], end: number[], strides: number[], beginMask: number,\n    endMask: number,\n    ellipsisMask: number): {begin: number[], end: number[], strides: number[]} {\n  const inputRank = inputShape.length;\n  let normalizedBegin = new Array(inputRank),\n      normalizedEnd = new Array(inputRank),\n      normalizedStrides = new Array(inputRank);\n  if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n    const fullIndex = ellipsisAxes[0];\n\n    // The ellipsis applies to the masked index as well as any dimensions\n    // that are interpolated.\n    const numElidedAxes = numInterpolatedAxes + 1;\n    normalizedBegin = startIndicesWithElidedDims(\n        beginMask, fullIndex, numElidedAxes, begin, inputShape);\n    normalizedEnd = stopIndicesWithElidedDims(\n        endMask, fullIndex, numElidedAxes, end, inputShape);\n    normalizedStrides =\n        stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n  } else {\n    for (let axis = 0; axis < inputRank; axis++) {\n      normalizedBegin[axis] = startForAxis(\n          beginMask, begin, strides, inputShape, axis, ellipsisMask);\n      normalizedEnd[axis] =\n          stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n    }\n  }\n\n  return {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  };\n}\n\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\nexport function startIndicesWithElidedDims(\n    beginMask: number, ellipsisInsertionIndex: number, numElidedAxes: number,\n    originalBegin: number[], inputShape: number[]): number[] {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = 0;\n    } else {\n      const originalAxis =\n          unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalBegin[originalAxis];\n      if (beginMask & 1 << originalAxis) {\n        originalValue = 0;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n  return newIndices;\n}\n\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\nexport function stopIndicesWithElidedDims(\n    endMask: number, ellipsisInsertionIndex: number, numElidedAxes: number,\n    originalEnd: number[], inputShape: number[]): number[] {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = Number.MAX_SAFE_INTEGER;\n    } else {\n      const originalAxis =\n          unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalEnd[originalAxis];\n      if (endMask & 1 << originalAxis) {\n        originalValue = Number.MAX_SAFE_INTEGER;\n      }\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  for (let i = 0; i < newIndices.length; i++) {\n    // Handle negative indices\n    const axisSize = inputShape[i];\n    if (newIndices[i] < 0) {\n      newIndices[i] += axisSize;\n    }\n    newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n  }\n  return newIndices;\n}\n\nexport function stridesForAxis(\n    strides: number[], axis: number, ellipsisMask: number): number {\n  let stride = strides[axis];\n  if (ellipsisMask & (1 << axis) || stride == null) {\n    stride = 1;\n  }\n\n  return stride;\n}\n\nexport function startForAxis(\n    beginMask: number, startIndices: number[], strides: number[],\n    inputShape: number[], axis: number, ellipsisMask: number): number {\n  // Begin with the specified index\n  let start = startIndices[axis];\n  const stride = strides[axis] || 1;\n\n  // Check the axis bit from right of masked axes, or the begin index is not set\n  // for the axis.\n  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n    if (stride > 0) {\n      // Forward iteration - use the first element. These values will get\n      // clamped below (Note: We could have set them to 0 and axis_size-1, but\n      // use lowest() and max() to maintain symmetry with StopForAxis())\n      start = Number.MIN_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the last element.\n      start = Number.MAX_SAFE_INTEGER;\n    }\n  }\n\n  // Handle negative indices\n  const axisSize = inputShape[axis];\n  if (start < 0) {\n    start += axisSize;\n  }\n\n  // Clamping\n  start = util.clamp(0, start, axisSize - 1);\n\n  return start;\n}\n\nexport function stopForAxis(\n    endMask: number, stopIndices: number[], strides: number[],\n    inputShape: number[], axis: number, ellipsisMask: number): number {\n  // Begin with the specified index\n  let stop = stopIndices[axis];\n  const stride = strides[axis] || 1;\n\n  // Check the axis bit from right of masked axes, or if the stop index is not\n  // set for this axis.\n  if (endMask & (1 << axis) || ellipsisMask & (1 << axis) || stop == null) {\n    if (stride > 0) {\n      // Forward iteration - use the last element. These values will get\n      // clamped below\n      stop = Number.MAX_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the first element.\n      stop = Number.MIN_SAFE_INTEGER;\n    }\n  }\n\n  // Handle negative indices\n  const axisSize = inputShape[axis];\n  if (stop < 0) {\n    stop += axisSize;\n  }\n\n  // Clamping\n  // Because the end index points one past the last element, we need slightly\n  // different clamping ranges depending on the direction.\n  if (stride > 0) {\n    // Forward iteration\n    stop = util.clamp(0, stop, axisSize);\n  } else {\n    // Backward iteration\n    stop = util.clamp(-1, stop, axisSize - 1);\n  }\n\n  return stop;\n}\n\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\nexport function isSliceContinous(\n    shape: number[], begin: number[], size: number[]) {\n  // Index of the first axis that has size > 1.\n  let firstNonOneAxis = size.length;\n  for (let i = 0; i < size.length; i++) {\n    if (size[i] > 1) {\n      firstNonOneAxis = i;\n      break;\n    }\n  }\n\n  for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n    if (begin[i] > 0 || size[i] !== shape[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function computeFlatOffset(begin: number[], strides: number[]): number {\n  let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n  for (let i = 0; i < begin.length - 1; i++) {\n    flatOffset += begin[i] * strides[i];\n  }\n  return flatOffset;\n}\n\nexport function parseSliceParams(\n    x: TensorInfo, begin: number|number[], size?: number|number[]) {\n  // The following logic allows for more ergonomic calls.\n  let begin_: number[];\n  const xRank = x.shape.length;\n  if (typeof begin === 'number') {\n    begin_ = [begin, ...new Array(xRank - 1).fill(0)];\n  } else if (begin.length < xRank) {\n    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n  } else {\n    begin_ = begin.slice();\n  }\n  begin_.forEach(d => {\n    util.assert(\n        d !== -1, () => 'slice() does not support negative begin indexing.');\n  });\n  let size_: number[];\n  if (size == null) {\n    size_ = new Array(xRank).fill(-1);\n  } else if (typeof size === 'number') {\n    size_ = [size, ...new Array(xRank - 1).fill(-1)];\n  } else if (size.length < xRank) {\n    size_ = size.concat(new Array(xRank - size.length).fill(-1));\n  } else {\n    size_ = size;\n  }\n  size_ = size_.map((d, i) => {\n    if (d >= 0) {\n      return d;\n    } else {\n      util.assert(\n          d === -1,\n          () => `Negative size values should be exactly -1 but got ` +\n              `${d} for the slice() size at index ${i}.`);\n      return x.shape[i] - begin_[i];\n    }\n  });\n  return [begin_, size_];\n}\n\nexport function sliceInfo(\n    xShape: number[], begin: number[], end: number[], strides: number[],\n    beginMask: number, endMask: number, ellipsisMask: number,\n    newAxisMask: number, shrinkAxisMask: number): SliceInfo {\n  // make a copy because it may be modified further down.\n  let $begin = begin.slice();\n  let $end = end.slice();\n  let $strides = strides;\n\n  if (strides == null) {\n    $strides = new Array($begin.length);\n  }\n\n  const ellipsisAxes = maskToAxes(ellipsisMask);\n  if (ellipsisAxes.length > 1) {\n    throw new Error('Multiple ellipses in slice is not allowed.');\n  }\n\n  if (ellipsisMask !== 0 && newAxisMask !== 0) {\n    throw new Error(\n        'Using both ellipsisMask and newAxisMask is not yet supported.');\n  }\n\n  if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\n    throw new Error(\n        'Using both ellipsisMask and shrinkAxisMask is not yet supported.');\n  }\n\n  const numInterpolatedAxes = xShape.length - $begin.length;\n\n  // Expand the dims of x based on the newAxisMask.\n  const expandAxes = maskToAxes(newAxisMask);\n  const newShape = xShape.slice();\n  expandAxes.forEach(axis => {\n    $begin[axis] = 0;\n    $end[axis] = 1;\n    newShape.splice(axis, 0, 1);\n  });\n\n  const {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  } =\n      getNormalizedAxes(\n          newShape, ellipsisAxes, numInterpolatedAxes, $begin, $end, $strides,\n          beginMask, endMask, ellipsisMask);\n  $begin = normalizedBegin;\n  $end = normalizedEnd;\n  $strides = normalizedStrides;\n\n  const shrinkAxes = maskToAxes(shrinkAxisMask);\n  // Adjust the ends based on the shrink mask.\n  shrinkAxes.forEach(axis => {\n    $end[axis] = $begin[axis] + 1;\n    $strides[axis] = 1;\n  });\n\n  // Figure out the output shape.\n  const size = computeOutShape($begin, $end, $strides);\n  // Remove the axes based on shrinkMask.\n  const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);\n\n  const nonStrided = $strides.every(v => v === 1);\n\n  return {nonStrided, $begin, $end, $strides, size, newShape, outShape};\n}\n"]}