{"version":3,"file":"in_top_k.js","sourceRoot":"","sources":["../../src/ops/in_top_k.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {assert, assertShapesMatch, getTypedArrayFromDType} from '../util';\nimport {tensor} from './tensor';\n\n/**\n * Returns whether the targets are in the top K predictions.\n *\n * ```js\n * const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\n * const targets = tf.tensor1d([2, 0]);\n * const precision = await tf.inTopKAsync(predictions, targets);\n * precision.print();\n * ```\n * @param predictions 2-D or higher `tf.Tensor` with last dimension being\n *     at least `k`.\n * @param targets 1-D or higher `tf.Tensor`.\n * @param k Optional Number of top elements to look at for computing precision,\n *     default to 1.\n *\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\n */\nasync function inTopKAsync_<T extends Tensor, U extends Tensor>(\n    predictions: T|TensorLike, targets: U|TensorLike, k = 1): Promise<U> {\n  const $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\n  const $targets = convertToTensor(targets, 'targets', 'inTopK');\n\n  assert(\n      $predictions.rank > 1,\n      () => 'inTopK() expects the predictions to be of rank 2 or higher, ' +\n          `but got ${$predictions.rank}`);\n  assert(\n      $predictions.rank - 1 === $targets.rank,\n      () => `predictions rank should be 1 larger than ` +\n          `targets rank, but got predictions rank ` +\n          `${$predictions.rank} and targets rank ${$targets.rank}`);\n  assertShapesMatch(\n      $predictions.shape.slice(0, $predictions.shape.length - 1),\n      $targets.shape,\n      `predictions's shape should be align with the targets' shape, ` +\n          'except the last dimension.');\n  const lastDim = $predictions.shape[$predictions.shape.length - 1];\n  assert(\n      k > 0 && k <= lastDim,\n      () => `'k' passed to inTopK() must be > 0 && <= the predictions last ` +\n          `dimension (${lastDim}), but got ${k}`);\n\n  const predictionsVals = await $predictions.data();\n  const targetsVals = await $targets.data();\n\n  // Reshape predictionsVals into a 2d tensor [batch, lastDim]\n  // and look up topK along lastDim.\n  const [batch, size] = [predictionsVals.length / lastDim, lastDim];\n  const precision = getTypedArrayFromDType('bool', batch);\n\n  for (let b = 0; b < batch; b++) {\n    const offset = b * size;\n    const vals = predictionsVals.subarray(offset, offset + size);\n    const valAndInd: Array<{value: number, index: number}> = [];\n    for (let i = 0; i < vals.length; i++) {\n      valAndInd.push({value: vals[i], index: i});\n    }\n    valAndInd.sort((a, b) => b.value - a.value);\n\n    precision[b] = 0;\n    for (let i = 0; i < k; i++) {\n      if (valAndInd[i].index === targetsVals[b]) {\n        precision[b] = 1;\n        break;\n      }\n    }\n  }\n\n  if (predictions !== $predictions) {\n    $predictions.dispose();\n  }\n  if (targets !== $targets) {\n    $targets.dispose();\n  }\n\n  // Output precision has the same shape as targets.\n  return tensor(precision, $targets.shape, 'bool') as U;\n}\n\nexport const inTopKAsync = inTopKAsync_;\n"]}