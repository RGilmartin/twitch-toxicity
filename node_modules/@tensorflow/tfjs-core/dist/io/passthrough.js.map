{"version":3,"file":"passthrough.js","sourceRoot":"","sources":["../../src/io/passthrough.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;GAeG;AAQH,MAAM,iBAAiB;IACrB,YAA6B,cAA+B;QAA/B,mBAAc,GAAd,cAAc,CAAiB;IAAG,CAAC;IAEhE,KAAK,CAAC,IAAI;QACR,OAAO,IAAI,CAAC,cAAc,CAAC;IAC7B,CAAC;CACF;AAED,MAAM,gBAAgB;IACpB,YACqB,WACqC;QADrC,gBAAW,GAAX,WAAW,CAC0B;IAAG,CAAC;IAE9D,KAAK,CAAC,IAAI,CAAC,cAA8B;QACvC,OAAO,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC;IAC1C,CAAC;CACF;AAED;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,MAAM,UAAU,UAAU,CACtB,cAAiC,EAAE,WAAoC,EACvE,UAAwB,EAAE,cAA+B;IAC3D,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;QAC1B,MAAM,gBAAgB,GACjB,cAAiC,CAAC,aAAa,IAAI,IAAI;YACvD,cAAiC,CAAC,WAAW,IAAI,IAAI,CAAC;QAC3D,IAAI,gBAAgB,EAAE;YACpB,OAAO,IAAI,iBAAiB,CAAC,cAAgC,CAAC,CAAC;SAChE;aAAM;YACL,2CAA2C;YAC3C,0CAA0C;YAC1C,OAAO,CAAC,IAAI,CACR,yDAAyD;gBACzD,iDAAiD;gBACjD,8DAA8D;gBAC9D,qDAAqD,CAAC,CAAC;YAC3D,OAAO,IAAI,iBAAiB,CAAC,EAAC,aAAa,EAAE,cAAoB,EAAC,CAAC,CAAC;SACrE;KACF;SAAM;QACL,kBAAkB;QAClB,0CAA0C;QAC1C,OAAO,CAAC,IAAI,CACR,yDAAyD;YACzD,iDAAiD;YACjD,8DAA8D;YAC9D,qDAAqD,CAAC,CAAC;QAC3D,OAAO,IAAI,iBAAiB,CAAC;YAC3B,aAAa,EAAE,cAAoB;YACnC,WAAW;YACX,UAAU;YACV,cAAc;SACf,CAAC,CAAC;KACJ;AACH,CAAC;AAED;;;;;;;;;;;;;;GAcG;AACH,MAAM,UAAU,eAAe,CAC3B,WACuB;IACzB,OAAO,IAAI,gBAAgB,CAAC,WAAW,CAAC,CAAC;AAC3C,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * IOHandlers that pass through the in-memory ModelArtifacts format.\n */\n\nimport {IOHandler, ModelArtifacts, SaveResult, TrainingConfig, WeightsManifestEntry} from './types';\n\nclass PassthroughLoader implements IOHandler {\n  constructor(private readonly modelArtifacts?: ModelArtifacts) {}\n\n  async load(): Promise<ModelArtifacts> {\n    return this.modelArtifacts;\n  }\n}\n\nclass PassthroughSaver implements IOHandler {\n  constructor(\n      private readonly saveHandler:\n          (artifacts: ModelArtifacts) => Promise<SaveResult>) {}\n\n  async save(modelArtifacts: ModelArtifacts) {\n    return this.saveHandler(modelArtifacts);\n  }\n}\n\n/**\n * Creates an IOHandler that loads model artifacts from memory.\n *\n * When used in conjunction with `tf.loadLayersModel`, an instance of\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\n *\n * ```js\n * const model = await tf.loadLayersModel(tf.io.fromMemory(\n *     modelTopology, weightSpecs, weightData));\n * ```\n *\n * @param modelArtifacts a object containing model topology (i.e., parsed from\n *   the JSON format).\n * @param weightSpecs An array of `WeightsManifestEntry` objects describing the\n *   names, shapes, types, and quantization of the weight data.\n * @param weightData A single `ArrayBuffer` containing the weight data,\n *   concatenated in the order described by the weightSpecs.\n * @param trainingConfig Model training configuration. Optional.\n *\n * @returns A passthrough `IOHandler` that simply loads the provided data.\n */\nexport function fromMemory(\n    modelArtifacts: {}|ModelArtifacts, weightSpecs?: WeightsManifestEntry[],\n    weightData?: ArrayBuffer, trainingConfig?: TrainingConfig): IOHandler {\n  if (arguments.length === 1) {\n    const isModelArtifacts =\n        (modelArtifacts as ModelArtifacts).modelTopology != null ||\n        (modelArtifacts as ModelArtifacts).weightSpecs != null;\n    if (isModelArtifacts) {\n      return new PassthroughLoader(modelArtifacts as ModelArtifacts);\n    } else {\n      // Legacy support: with only modelTopology.\n      // TODO(cais): Remove this deprecated API.\n      console.warn(\n          'Please call tf.io.fromMemory() with only one argument. ' +\n          'The argument should be of type ModelArtifacts. ' +\n          'The multi-argument signature of tf.io.fromMemory() has been ' +\n          'deprecated and will be removed in a future release.');\n      return new PassthroughLoader({modelTopology: modelArtifacts as {}});\n    }\n  } else {\n    // Legacy support.\n    // TODO(cais): Remove this deprecated API.\n    console.warn(\n        'Please call tf.io.fromMemory() with only one argument. ' +\n        'The argument should be of type ModelArtifacts. ' +\n        'The multi-argument signature of tf.io.fromMemory() has been ' +\n        'deprecated and will be removed in a future release.');\n    return new PassthroughLoader({\n      modelTopology: modelArtifacts as {},\n      weightSpecs,\n      weightData,\n      trainingConfig\n    });\n  }\n}\n\n/**\n * Creates an IOHandler that passes saved model artifacts to a callback.\n *\n * ```js\n * function handleSave(artifacts) {\n *   // ... do something with the artifacts ...\n *   return {modelArtifactsInfo: {...}, ...};\n * }\n *\n * const saveResult = model.save(tf.io.withSaveHandler(handleSave));\n * ```\n *\n * @param saveHandler A function that accepts a `ModelArtifacts` and returns a\n *     `SaveResult`.\n */\nexport function withSaveHandler(\n    saveHandler: (artifacts: ModelArtifacts) =>\n        Promise<SaveResult>): IOHandler {\n  return new PassthroughSaver(saveHandler);\n}\n"]}