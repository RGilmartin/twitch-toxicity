{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/keras_format/types.ts"],"names":[],"mappings":"AAAA;;;;;;;;GAQG","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * A value within the JSON-serialized form of a serializable object.\n *\n * The keys of any nested dicts should be in snake_case (i.e., using Python\n * naming conventions) for compatibility with Python Keras.\n *\n * @see PyJsonDict\n */\nexport type PyJsonValue = boolean|number|string|null|PyJsonArray|PyJsonDict;\n\n/**\n * A key-value dict within the JSON-serialized form of a serializable object.\n *\n * Serialization/deserialization uses stringified-JSON as the storage\n * representation. Typically this should be used for materialized JSON\n * stored on disk or sent/received over the wire.\n *\n * The keys of this dict and of any nested dicts should be in snake_case (i.e.,\n * using Python naming conventions) for compatibility with Python Keras.\n *\n * Internally this is normally converted to a ConfigDict that has CamelCase keys\n * (using TypeScript naming conventions) and support for Enums.\n */\nexport interface PyJsonDict {\n  [key: string]: PyJsonValue;\n}\n\n/**\n * A key-value dict like @see PyJsonDict, but with restricted keys.\n *\n * This makes it possible to create subtypes that have only the specified\n * fields, while requiring that the values are JSON-compatible.\n *\n * That is in contrast to extending `PyJsonDict`, or using an intersection type\n * `Foo & PyJsonDict`.  In both of those cases, the fields of Foo are actually\n * allowed to be of types that are incompatible with `PyJsonValue`.  Worse, the\n * index signature of `PyJsonValue` means that *any* key is accepted: eg.\n * `const foo: Foo = ...; foo.bogus = 12; const x = foo.bogus` works for both\n * reading and assignment, even if `bogus` is not a field of the type `Foo`,\n * because the index signature inherited from `PyJsonDict` accepts all strings.\n *\n * Here, we *both* restrict the keys to known values, *and* guarantee that the\n * values associated with those keys are compatible with `PyJsonValue`.\n *\n * This guarantee is easiest to apply via an additional incantation:\n *\n * ```\n * export interface Foo extends PyJson<keyof Foo> {\n *   a: SomeType;\n *   b: SomeOtherType;\n * }\n * ```\n *\n * Now instances of `Foo` have *only* the fields `a` and `b`, and furthermore,\n * if either the type `SomeType` or `SomeOtherType` is incompatible with\n * `PyJsonValue`, the compiler produces a typing error.\n */\nexport type PyJson<Keys extends string> = {\n  [x in Keys]?: PyJsonValue;\n};\n\n/**\n * An array of values within the JSON-serialized form of a serializable object.\n *\n * The keys of any nested dicts should be in snake_case (i.e., using Python\n * naming conventions) for compatibility with Python Keras.\n *\n * @see PyJsonDict\n */\nexport interface PyJsonArray extends Array<PyJsonValue> {}\n\n/**\n * A Keras JSON entry representing a Keras object such as a Layer.\n *\n * The Keras JSON convention is to provide the `class_name` (e.g., the layer\n * type) at the top level, and then to place the class-specific configuration in\n * a `config` subtree.  These class-specific configurations are provided by\n * subtypes of `PyJsonDict`.  Thus, this `*Serialization` has a type parameter\n * giving the specific type of the wrapped `PyJsonDict`.\n */\nexport interface BaseSerialization<\n    N extends string, T extends PyJson<Extract<keyof T, string>>> extends\n    PyJsonDict {\n  // The above type voodoo does this:\n  // * `keyof T` obtains the known keys of the specific config type.\n  //   `keyof` returns `string | number | symbol`; see\n  //   (https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html)\n  // * `Extract<keyof T, string>` selects the string values.  This amounts to\n  //    assuming that we are dealing with a type with string keys, as opposed to\n  //    an array.  In our usage, this assumption always holds.\n  // * `PyJson<Extract<keyof T, string>>` is a type whose keys are constrained\n  //    to the provided ones, and whose values must be JSON-compatible.\n  // * `T extends PyJson<Extract<keyof T, string>> means that we can provide any\n  //    config type with known keys, provided that the associated values are\n  //    JSON-compatible.\n  //\n  // The upshot is that we can extend `BaseSerialization` with whatever config\n  // type `T` that we like-- remaining confident that the result can be\n  // trivially rendered as JSON, because the compiler will produce a typing\n  // error if that guarantee does not hold.\n  //\n  // To test this, try adding a field with a non-JSON-like value (e.g., Tensor)\n  // to any subclass of `BaseSerialization`.  A compilation error will result.\n  class_name: N;\n  config: T;\n}\n"]}