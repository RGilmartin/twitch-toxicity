{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"AAAA;;;;;;;;GAQG","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/** Defines allowable data types for tensors. */\n\nimport {NamedTensorMap, Scalar, Tensor} from '@tensorflow/tfjs-core';\n\nimport {Shape} from './keras_format/common';\n\nexport interface NamedTensor {\n  name: string;\n  tensor: Tensor;\n}\n\nexport type HasShape = {\n  shape: Shape;\n};\n\n/**\n * Type for loss a metric function.\n *\n * Takes a true value and a predicted value, and returns a loss or metric value.\n */\nexport type LossOrMetricFn = (yTrue: Tensor, yPred: Tensor) => Tensor;\n\n/**\n * Type for a regularizer function.\n */\nexport type RegularizerFn = () => Scalar;\n\n/*\n * The type for an RNN step function.\n * The arguments are:\n *   - inputs: Input data, with shape `[sapmles, ...]`.\n * The return values are:\n *   - outputs: tensor with shape `[samples, outputDim]` (no time dimension).\n *   - newStates: Array of tensors. The `Array` has the same length as `states`\n *     in the input arguments. Each `tf.Tensor` has the same shape as the\n *     corresponding element in `states`.\n */\nexport type RnnStepFunction =\n    (inputs: Tensor, states: Tensor[]) => [Tensor, Tensor[]];\n\n/**\n * A single Tensor or a non-nested collection of Tensors.\n *\n * An object of this type can always be reduced to `Tensor[]`.  A single\n * 'Tensor' becomes `[Tensor]`.  A `Tensor[]` is unchanged.  A `NamedTensorMap`\n * can be converted with the help of a list of names, providing the order in\n * which the Tensors should appear in the resulting array.\n */\nexport type TensorOrArrayOrMap = Tensor|Tensor[]|NamedTensorMap;\n\n/**\n * Type representing a loosely-typed bundle of keyword arguments.\n *\n * This is a looser type than PyJsonDict/serialization.ConfigDict as it\n * can contain arbitrary objects as its values.  It is most appropriate\n * for functions that pass through keyword arguments to other functions\n * without knowledge of the structure.  If the function can place type\n * restrictions on the keyword arguments, it should via the Config\n * interface convention used throughout.\n */\nexport type Kwargs = {\n  // tslint:disable-next-line:no-any\n  [key: string]: any\n};\n"]}