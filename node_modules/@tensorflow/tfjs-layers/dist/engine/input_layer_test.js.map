{"version":3,"file":"input_layer_test.js","sourceRoot":"","sources":["../../src/engine/input_layer_test.ts"],"names":[],"mappings":"AAAA;;;;;;;;GAQG;AAEH,OAAO,EAAC,IAAI,EAAC,MAAM,uBAAuB,CAAC;AAE3C,OAAO,KAAK,GAAG,MAAM,UAAU,CAAC;AAChC,OAAO,EAAC,eAAe,EAAC,MAAM,qBAAqB,CAAC;AAEpD,OAAO,EAAC,KAAK,EAAC,MAAM,eAAe,CAAC;AAGpC,eAAe,CAAC,YAAY,EAAE,GAAG,EAAE;IACjC,EAAE,CAAC,sDAAsD,EAAE,GAAG,EAAE;QAC9D,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;aAClC,YAAY,CAAC,oCAAoC,CAAC,CAAC;IAC1D,CAAC,CAAC,CAAC;IACH,QAAQ,CAAC,qCAAqC,EAAE,GAAG,EAAE;QACnD,MAAM,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;QACvB,MAAM,UAAU,GAAG,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,EAAC,UAAU,EAAC,CAAC,CAAC;QAEvD,EAAE,CAAC,mBAAmB,EAAE,GAAG,EAAE;YAC3B,MAAM,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC3C,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,WAAW,EAAE,GAAG,EAAE;YACnB,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACtC,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,gBAAgB,EAAE,GAAG,EAAE;YACxB,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACxC,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,+BAA+B,EAAE,GAAG,EAAE;YACvC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;QAC/C,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,yDAAyD,EAAE,GAAG,EAAE;YACjE,MAAM,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;QACxE,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,sBAAsB,EAAE,GAAG,EAAE;YAC9B,MAAM,CAAC,UAAU,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QACrD,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,qBAAqB,EAAE,GAAG,EAAE;YAC7B,MAAM,CAAC,UAAU,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QACpD,CAAC,CAAC,CAAC;QAEH,QAAQ,CAAC,yBAAyB,EAAE,GAAG,EAAE;YACvC,MAAM,WAAW,GAAG,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;YAC/C,EAAE,CAAC,sDAAsD,EAAE,GAAG,EAAE;gBAC9D,MAAM,CAAC,WAAW,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBACpD,MAAM,CAAC,WAAW,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBAClD,MAAM,CAAC,WAAW,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YACtD,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,wCAAwC,EAAE,GAAG,EAAE;gBAChD,MAAM,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBAC/C,MAAM,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YAClD,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,yCAAyC,EAAE,GAAG,EAAE;gBACjD,MAAM,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC,OAAO,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;gBAClE,MAAM,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YACvE,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,uBAAuB,EAAE,GAAG,EAAE;gBACrC,MAAM,cAAc,GAAG,WAAW,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;gBAEnD,EAAE,CAAC,kBAAkB,EAAE,GAAG,EAAE;oBAC1B,MAAM,CAAC,cAAc,YAAY,GAAG,CAAC,cAAc,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAClE,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,+CAA+C,EAAE,GAAG,EAAE;oBACvD,MAAM,CAAC,WAAW,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;oBACnD,MAAM,CAAC,WAAW,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;oBACpD,MAAM,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC,OAAO,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC;gBACtE,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,mCAAmC,EAAE,GAAG,EAAE;oBAC3C,MAAM,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;oBAC5C,MAAM,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBAChD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,uCAAuC,EAAE,GAAG,EAAE;oBAC/C,MAAM,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;gBACzD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,2CAA2C,EAAE,GAAG,EAAE;oBACnD,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;gBACvD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,uCAAuC,EAAE,GAAG,EAAE;oBAC/C,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;gBACzD,CAAC,CAAC,CAAC;gBAEH,EAAE,CAAC,sDAAsD,EAAE,GAAG,EAAE;oBAC9D,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC;gBACnE,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,qDAAqD;IACrD,EAAE,CAAC,uBAAuB,EAAE,GAAG,EAAE;QAC/B,MAAM,UAAU,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;QAC7B,MAAM,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,EAAC,UAAU,EAAC,CAAC,CAAC;QACnD,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;IACvE,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,6DAA6D;QACzD,sCAAsC,EAC1C,GAAG,EAAE;QACH,MAAM,CACF,GAAG,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,EAAC,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE,eAAe,EAAE,CAAC,CAAC,CAAC,EAAC,CAAC,CAAC;aACpE,YAAY,CAAC,gDAAgD,CAAC,CAAC;IACtE,CAAC,CAAC,CAAC;IAEN,KAAK,MAAM,SAAS,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE;QACjC,EAAE,CAAC,sDAAsD,EAAE,GAAG,EAAE;YAC9D,MAAM,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;YACvB,MAAM,UAAU,GAAG,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,EAAC,UAAU,EAAE,SAAS,EAAC,CAAC,CAAC;YAClE,MAAM,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC,OAAO,CAAC;gBACzC,SAAS;aACV,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;QACxB,CAAC,CAAC,CAAC;KACJ;IAED,EAAE,CAAC,gDAAgD,EAAE,GAAG,EAAE;QACxD,MAAM,eAAe,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/B,MAAM,UAAU,GAAG,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,EAAC,eAAe,EAAC,CAAC,CAAC;QAC5D,MAAM,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;IAC9D,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,wEAAwE,EACxE,GAAG,EAAE;QACH,MAAM,eAAe,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/B,MAAM,UAAU,GAAG,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,EAAC,eAAe,EAAC,CAAC,CAAC;QAC5D,MAAM,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;IAC9D,CAAC,CAAC,CAAC;IAEN,EAAE,CAAC,kEAAkE,EAAE,GAAG,EAAE;QAC1E,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,EAAC,eAAe,EAAE,CAAC,CAAC,CAAC,EAAE,SAAS,EAAE,CAAC,EAAC,CAAC,CAAC;aACpE,YAAY,CAAC,6CAA6C,CAAC,CAAC;IACnE,CAAC,CAAC,CAAC;IAEH,KAAK,MAAM,MAAM,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE;QAClC,EAAE,CAAC,2CAA2C,EAAE,GAAG,EAAE;YACnD,MAAM,UAAU,GACZ,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,EAAC,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE,MAAM,EAAC,CAAC,CAAC;YACrD,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QAC5C,CAAC,CAAC,CAAC;KACJ;IAED,EAAE,CAAC,yCAAyC,EAAE,GAAG,EAAE;QACjD,MAAM,KAAK,GAAG,SAAS,CAAC;QACxB,MAAM,UAAU,GAAG,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,EAAC,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE,KAAK,EAAC,CAAC,CAAC;QACnE,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IAC1C,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,wCAAwC,EAAE,GAAG,EAAE;QAChD,MAAM,IAAI,GAAG,KAAK,CAAC;QACnB,MAAM,UAAU,GAAG,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,EAAC,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,EAAC,CAAC,CAAC;QAClE,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IACxC,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,0DAA0D,EAAE,GAAG,EAAE;QAClE,MAAM,UAAU,GAAG,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,EAAC,UAAU,EAAE,CAAC,CAAC,CAAC,EAAC,CAAC,CAAC;QAC5D,MAAM,cAAc,GAAG,IAAI,GAAG,CAAC,cAAc,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;QAC5E,MAAM,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;aACzC,YAAY,CAAC,gDAAgD,CAAC,CAAC;IACtE,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,+DAA+D;QAC3D,qBAAqB,EACzB,GAAG,EAAE;QACH,MAAM,UAAU,GAAG,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,EAAC,UAAU,EAAE,CAAC,CAAC,CAAC,EAAC,CAAC,CAAC;QAC5D,MAAM,MAAM,GAAG,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,YAAY,EAAE,CAAC;IACxD,CAAC,CAAC,CAAC;IAEN,EAAE,CAAC,gCAAgC,EAAE,GAAG,EAAE;QACxC,MAAM,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC;QAC5B,MAAM,KAAK,GAAG,SAAS,CAAC;QACxB,MAAM,MAAM,GAAG,IAAI,CAAC;QACpB,MAAM,IAAI,GAAG,SAAS,CAAC;QACvB,MAAM,UAAU,GACZ,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,EAAC,eAAe,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAC,CAAC,CAAC;QAClE,MAAM,CAAC,UAAU,CAAC,SAAS,EAAE,CAAC;aACzB,OAAO,CAAC,EAAC,eAAe,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAC,CAAC,CAAC;IACvD,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC;AAEH,MAAM,YAAa,SAAQ,GAAG,CAAC,MAAM,CAAC,KAAK;IAEzC,YAAY,IAAe;QACzB,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;;AAHM,sBAAS,GAAG,cAAc,CAAC;AAMpC,QAAQ,CAAC,SAAS,EAAE,GAAG,EAAE;IACvB,EAAE,CAAC,mEAAmE,EACnE,GAAG,EAAE;QACH,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aAC7B,YAAY,CAAC,gCAAgC,CAAC,CAAC;IACtD,CAAC,CAAC,CAAC;IAEN,MAAM,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;IAClB,MAAM,UAAU,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC1B,MAAM,IAAI,GAAG,KAAK,CAAC;IACnB,MAAM,KAAK,GAAG,SAAS,CAAC;IAExB,EAAE,CAAC,sDAAsD,EAAE,GAAG,EAAE;QAC9D,MAAM,cAAc,GAAG,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,EAAC,KAAK,EAAE,IAAI,EAAE,KAAK,EAAC,CAAC,CAAC;QAC9D,MAAM,CAAC,cAAc,YAAY,GAAG,CAAC,cAAc,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAChE,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;QAC3D,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAC3C,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IAC9C,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,6CAA6C,EAAE,GAAG,EAAE;QACrD,MAAM,cAAc,GAAG,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,EAAC,UAAU,EAAC,CAAC,CAAC;QACtD,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;IACnD,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,8DAA8D,EAAE,GAAG,EAAE;QACtE,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,EAAC,KAAK,EAAE,UAAU,EAAC,CAAC,CAAC;aAC9C,YAAY,CAAC,iCAAiC,CAAC,CAAC;IACvD,CAAC,CAAC,CAAC;IAEH,EAAE,CAAC,6CAA6C,EAAE,GAAG,EAAE;QACrD,MAAM,WAAW,GAAG,KAAK,CAAC,EAAC,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC;QACzC,MAAM,UAAU,GAAG,IAAI,YAAY,CAAC,EAAC,IAAI,EAAE,YAAY,EAAC,CAAC,CAAC;QAC1D,MAAM,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC,WAAW,CAAuB,CAAC;QACnE,MAAM,CAAC,MAAM,YAAY,GAAG,CAAC,cAAc,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACxD,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,uBAAuB,CAAC,CAAC;IACvD,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport {ones} from '@tensorflow/tfjs-core';\n\nimport * as tfl from '../index';\nimport {describeMathCPU} from '../utils/test_utils';\n\nimport {Input} from './input_layer';\nimport {LayerArgs} from './topology';\n\ndescribeMathCPU('InputLayer', () => {\n  it('when initialized to its defaults throws an exception', () => {\n    expect(() => tfl.layers.inputLayer({}))\n        .toThrowError(/InputLayer should be passed either/);\n  });\n  describe('initialized with only an inputShape', () => {\n    const inputShape = [1];\n    const inputLayer = tfl.layers.inputLayer({inputShape});\n\n    it('is not trainable.', () => {\n      expect(inputLayer.trainable).toBe(false);\n    });\n\n    it('is built.', () => {\n      expect(inputLayer.built).toBe(true);\n    });\n\n    it('is not sparse.', () => {\n      expect(inputLayer.sparse).toBe(false);\n    });\n\n    it('automatically assigns a name.', () => {\n      expect(inputLayer.name).toMatch(/^input.*$/);\n    });\n\n    it('creates a batchInputShape of [null].concat(inputShape).', () => {\n      expect(inputLayer.batchInputShape).toEqual([null].concat(inputShape));\n    });\n\n    it('has no outboundNodes', () => {\n      expect(inputLayer.outboundNodes.length).toEqual(0);\n    });\n\n    it('has one inboundNode', () => {\n      expect(inputLayer.inboundNodes.length).toEqual(1);\n    });\n\n    describe('creates an inbound Node', () => {\n      const inboundNode = inputLayer.inboundNodes[0];\n      it('with no inboundLayers, nodeIndices, or tensorIndices', () => {\n        expect(inboundNode.inboundLayers.length).toEqual(0);\n        expect(inboundNode.nodeIndices.length).toEqual(0);\n        expect(inboundNode.tensorIndices.length).toEqual(0);\n      });\n\n      it('with [null] inputMasks and outputMasks', () => {\n        expect(inboundNode.inputMasks).toEqual([null]);\n        expect(inboundNode.outputMasks).toEqual([null]);\n      });\n\n      it('with equal inputShapes and outputShapes', () => {\n        expect(inboundNode.inputShapes).toEqual(inboundNode.outputShapes);\n        expect(inboundNode.inputShapes).toEqual([[null].concat(inputShape)]);\n      });\n\n      describe('with a SymbolicTensor', () => {\n        const symbolicTensor = inboundNode.inputTensors[0];\n\n        it('that is defined.', () => {\n          expect(symbolicTensor instanceof tfl.SymbolicTensor).toBe(true);\n        });\n\n        it('assigned to both the input and outputTensors.', () => {\n          expect(inboundNode.inputTensors.length).toEqual(1);\n          expect(inboundNode.outputTensors.length).toEqual(1);\n          expect(inboundNode.inputTensors).toEqual(inboundNode.outputTensors);\n        });\n\n        it('with a node and tensorIndex of 0.', () => {\n          expect(symbolicTensor.nodeIndex).toEqual(0);\n          expect(symbolicTensor.tensorIndex).toEqual(0);\n        });\n\n        it('with a sourceLayer of the inputLayer.', () => {\n          expect(symbolicTensor.sourceLayer).toEqual(inputLayer);\n        });\n\n        it('with a name matching the inputLayer name.', () => {\n          expect(symbolicTensor.name).toEqual(inputLayer.name);\n        });\n\n        it('with a dtype equal to the inputLayer.', () => {\n          expect(symbolicTensor.dtype).toEqual(inputLayer.dtype);\n        });\n\n        it('with a shape matching the inputLayer.batchInputShape', () => {\n          expect(symbolicTensor.shape).toEqual(inputLayer.batchInputShape);\n        });\n      });\n    });\n  });\n\n  // See https://github.com/tensorflow/tfjs/issues/1341\n  it('allow `null` in shape', () => {\n    const inputShape = [null, 2];\n    const inputs = tfl.layers.inputLayer({inputShape});\n    expect(inputs.inputSpec[0].shape).toEqual([null].concat(inputShape));\n  });\n\n  it('throws an exception if both inputShape and batchInputShape ' +\n         'are specified during initialization.',\n     () => {\n       expect(\n           () => tfl.layers.inputLayer({inputShape: [1], batchInputShape: [1]}))\n           .toThrowError(/Only provide the inputShape OR batchInputShape/);\n     });\n\n  for (const batchSize of [null, 5]) {\n    it('initializes with batchSize when inputShape specified', () => {\n      const inputShape = [1];\n      const inputLayer = tfl.layers.inputLayer({inputShape, batchSize});\n      expect(inputLayer.batchInputShape).toEqual([\n        batchSize\n      ].concat(inputShape));\n    });\n  }\n\n  it('initializes with batchInputShape if specified.', () => {\n    const batchInputShape = [1, 2];\n    const inputLayer = tfl.layers.inputLayer({batchInputShape});\n    expect(inputLayer.batchInputShape).toEqual(batchInputShape);\n  });\n\n  it('initializes with batchInputShape if null specified for the batch size.',\n     () => {\n       const batchInputShape = [1, 2];\n       const inputLayer = tfl.layers.inputLayer({batchInputShape});\n       expect(inputLayer.batchInputShape).toEqual(batchInputShape);\n     });\n\n  it('throws exception if batchSize and batchInputShape are specified.', () => {\n    expect(() => tfl.layers.inputLayer({batchInputShape: [1], batchSize: 5}))\n        .toThrowError(/Cannot specify batchSize if batchInputShape/);\n  });\n\n  for (const sparse of [true, false]) {\n    it('uses config.sparse during initialization.', () => {\n      const inputLayer =\n          tfl.layers.inputLayer({inputShape: [1], sparse});\n      expect(inputLayer.sparse).toEqual(sparse);\n    });\n  }\n\n  it('use config.dtype during initialization.', () => {\n    const dtype = 'float32';\n    const inputLayer = tfl.layers.inputLayer({inputShape: [1], dtype});\n    expect(inputLayer.dtype).toEqual(dtype);\n  });\n\n  it('use config.name during initialization.', () => {\n    const name = 'abc';\n    const inputLayer = tfl.layers.inputLayer({inputShape: [1], name});\n    expect(inputLayer.name).toEqual(name);\n  });\n\n  it('throws an exception if apply() is called with any input.', () => {\n    const inputLayer = tfl.layers.inputLayer({inputShape: [1]});\n    const symbolicTensor = new tfl.SymbolicTensor('float32', [2], null, [], {});\n    expect(() => inputLayer.apply(symbolicTensor))\n        .toThrowError(/Cannot pass any input to an InputLayer's apply/);\n  });\n\n  it('throws an exception if its inputs differ in shape to what it ' +\n         'was initialized to.',\n     () => {\n       const inputLayer = tfl.layers.inputLayer({inputShape: [1]});\n       const inputs = ones([2, 2]);\n       expect(() => inputLayer.apply(inputs)).toThrowError();\n     });\n\n  it('returns a serializable config.', () => {\n    const batchInputShape = [1];\n    const dtype = 'float32';\n    const sparse = true;\n    const name = 'my_name';\n    const inputLayer =\n        tfl.layers.inputLayer({batchInputShape, dtype, sparse, name});\n    expect(inputLayer.getConfig())\n        .toEqual({batchInputShape, dtype, sparse, name});\n  });\n});\n\nclass LayerForTest extends tfl.layers.Layer {\n  static className = 'LayerForTest';\n  constructor(args: LayerArgs) {\n    super(args);\n  }\n}\n\ndescribe('Input()', () => {\n  it('throws an exception if neither shape nor batchShape are specified',\n     () => {\n       expect(() => tfl.layers.input({}))\n           .toThrowError(/Please provide to Input either/);\n     });\n\n  const shape = [1];\n  const batchShape = [2, 2];\n  const name = 'abc';\n  const dtype = 'float32';\n\n  it('returns an initialized symbolicTensor given a shape.', () => {\n    const symbolicTensor = tfl.layers.input({shape, name, dtype});\n    expect(symbolicTensor instanceof tfl.SymbolicTensor).toBe(true);\n    expect(symbolicTensor.shape).toEqual([null].concat(shape));\n    expect(symbolicTensor.name).toMatch(/abc/);\n    expect(symbolicTensor.dtype).toEqual(dtype);\n  });\n\n  it('returns a SymbolicTensor given a batchShape', () => {\n    const symbolicTensor = tfl.layers.input({batchShape});\n    expect(symbolicTensor.shape).toEqual(batchShape);\n  });\n\n  it('throws exception if both shape and batchShape are specified.', () => {\n    expect(() => tfl.layers.input({shape, batchShape}))\n        .toThrowError(/Please provide either a `shape`/);\n  });\n\n  it('produces output that can feed into a Layer.', () => {\n    const inputTensor = Input({shape, name});\n    const otherLayer = new LayerForTest({name: 'firstLayer'});\n    const output = otherLayer.apply(inputTensor) as tfl.SymbolicTensor;\n    expect(output instanceof tfl.SymbolicTensor).toBe(true);\n    expect(output.name).toEqual('firstLayer/firstLayer');\n  });\n});\n"]}