{"version":3,"file":"crop_and_resize_gpu.js","sourceRoot":"","sources":["../src/crop_and_resize_gpu.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;GAeG;AAIH,MAAM,OAAO,oBAAoB;IAK/B,YACI,UAA4C,EAAE,QAA0B,EACxE,QAA0B,EAAE,MAA4B,EACxD,kBAA0B;QAP9B,kBAAa,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;QAC7C,gBAAW,GAAa,EAAE,CAAC;QAOzB,MAAM,CAAC,KAAK,EAAE,WAAW,EAAE,UAAU,EAAE,KAAK,CAAC,GAAG,UAAU,CAAC;QAC3D,MAAM,CAAC,QAAQ,EAAG,GAAG,QAAQ,CAAC;QAC9B,MAAM,CAAC,UAAU,EAAE,SAAS,CAAC,GAAG,QAAQ,CAAC;QACzC,IAAI,CAAC,WAAW,GAAG,CAAC,QAAQ,EAAE,UAAU,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;QAC5D,MAAM,QAAQ,GAAG,MAAM,KAAK,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAE/C,MAAM,CAAC,gBAAgB,EAAE,eAAe,CAAC,GACrC,CAAC,GAAG,WAAW,GAAG,CAAC,IAAI,EAAE,GAAG,UAAU,GAAG,CAAC,IAAI,CAAC,CAAC;QAEpD,MAAM,CAAC,WAAW,EAAE,WAAW,EAAE,GAAG,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC,CAAC;YACpD;gBACE,GAAG,CAAC,WAAW,GAAG,CAAC,CAAC,GAAG,CAAC,UAAU,GAAG,CAAC,CAAC,EAAE;gBACzC,wBAAwB;gBACxB,MAAM,gBAAgB,4BAA4B;aACnD,CAAC,CAAC;YACH;gBACE,KAAK;gBACL,KAAK;gBACL,mBAAmB,gBAAgB,EAAE;aACtC,CAAC;QACN,MAAM,CAAC,UAAU,EAAE,UAAU,EAAE,GAAG,CAAC,GAAG,SAAS,GAAG,CAAC,CAAC,CAAC;YACjD;gBACE,GAAG,CAAC,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,SAAS,GAAG,CAAC,CAAC,EAAE;gBACvC,uBAAuB;gBACvB,MAAM,eAAe,2BAA2B;aACjD,CAAC,CAAC;YACH;gBACE,KAAK;gBACL,KAAK;gBACL,mBAAmB,eAAe,EAAE;aACrC,CAAC;QAEN,2BAA2B;QAC3B,2CAA2C;QAC3C,4GAA4G;QAC5G,IAAI,CAAC,QAAQ,GAAG;yCACqB,WAAW;wCACZ,UAAU;;;;;;;;;;;;;;;;iCAgBjB,KAAK;;;;+BAIP,WAAW;8BACZ,UAAU;;uBAEjB,GAAG;mCACS,gBAAgB;4BACvB,kBAAkB;;;uBAGvB,GAAG;mCACS,eAAe;4BACtB,kBAAkB;;;;;aAKjC,QAAQ;;;;;;;;;;;;;;;;;;;;;;;;KAwBhB,CAAC;IACJ,CAAC;CACF","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class CropAndResizeProgram implements GPGPUProgram {\n  variableNames = ['Image', 'Boxes', 'BoxInd'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      imageShape: [number, number, number, number], boxShape: [number, number],\n      cropSize: [number, number], method: 'bilinear'|'nearest',\n      extrapolationValue: number) {\n    const [batch, imageHeight, imageWidth, depth] = imageShape;\n    const [numBoxes, ] = boxShape;\n    const [cropHeight, cropWidth] = cropSize;\n    this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n    const methodId = method === 'bilinear' ? 1 : 0;\n\n    const [inputHeightFloat, inputWidthFloat] =\n        [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];\n\n    const [heightRatio, heightScale, inY] = cropHeight > 1 ?\n        [\n          `${(imageHeight - 1) / (cropHeight - 1)}`,\n          '(y2-y1) * height_ratio',\n          `y1*${inputHeightFloat} + float(y)*(height_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (y1+y2) * ${inputHeightFloat}`,\n        ];\n    const [widthRatio, widthScale, inX] = cropWidth > 1 ?\n        [\n          `${(imageWidth - 1) / (cropWidth - 1)}`,\n          '(x2-x1) * width_ratio',\n          `x1*${inputWidthFloat} + float(x)*(width_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (x1+x2) * ${inputWidthFloat}`,\n        ];\n\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n    this.userCode = `\n      const float height_ratio = float(${heightRatio});\n      const float width_ratio = float(${widthRatio});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${batch}) {\n          return;\n        }\n\n        float height_scale = ${heightScale};\n        float width_scale = ${widthScale};\n\n        float in_y = ${inY};\n        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n        float in_x = ${inX};\n        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${methodId} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `;\n  }\n}\n"]}