{"version":3,"file":"reduce_gpu.js","sourceRoot":"","sources":["../src/reduce_gpu.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;GAeG;AAKH,MAAM,OAAO,aAAa;IAKxB,YACI,UAAmC,EACnC,UAAgD;QANpD,kBAAa,GAAG,CAAC,GAAG,CAAC,CAAC;QAOpB,MAAM,EAAC,UAAU,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,EAAC,GAAG,UAAU,CAAC;QAC5D,IAAI,CAAC,WAAW,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QAExC,IAAI,mBAAmB,GAAG,KAAK,CAAC;QAChC,IAAI,SAAS,GAAG,EAAE,CAAC;QAEnB,IAAI,UAAU,KAAK,MAAM,EAAE;YACzB,mBAAmB,GAAG,KAAK,CAAC;SAC7B;aAAM,IAAI,UAAU,KAAK,KAAK,EAAE;YAC/B,2DAA2D;YAC3D,mBAAmB,GAAG,aAAa,CAAC;YACpC,SAAS,GAAG,KAAK,CAAC;SACnB;aAAM,IAAI,UAAU,KAAK,KAAK,EAAE;YAC/B,2DAA2D;YAC3D,mBAAmB,GAAG,cAAc,CAAC;YACrC,SAAS,GAAG,KAAK,CAAC;SACnB;QAED,IAAI,WAAW,GAAG,GAAG,UAAU,IAAI,UAAU,IAAI,UAAU,GAAG;YAC1D,mEAAmE,CAAC;QAExE,IAAI,UAAU,KAAK,KAAK,EAAE;YACxB,WAAW,GAAG,UAAU,CAAC;SAC1B;aAAM,IAAI,UAAU,KAAK,MAAM,EAAE;YAChC,WAAW,GAAG,WAAW,CAAC;SAC3B;aAAM,IAAI,UAAU,KAAK,KAAK,EAAE;YAC/B,WAAW,GAAG,UAAU,CAAC;SAC1B;aAAM,IAAI,UAAU,KAAK,KAAK,EAAE;YAC/B,WAAW,GAAG,UAAU,CAAC;SAC1B;QAED,MAAM,qBAAqB,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QAC7D,MAAM,uBAAuB,GAAG,UAAU,GAAG,CAAC,CAAC;QAE/C,IAAI,aAAa,GAAG;YACZ,UAAU,KAAK,KAAK;;mBAEb,UAAU,KAAK,MAAM;;;;wBAIhB,SAAS;;KAE5B,CAAC;QAEF,IAAI,OAAO,GAAG,MAAM,CAAC;QAErB,IAAI,UAAU,KAAK,KAAK,EAAE;YACxB,mBAAmB,GAAG,KAAK,CAAC;YAC5B,aAAa,GAAG;;;;OAIf,CAAC;YACF,OAAO,GAAG,OAAO,CAAC;SACnB;aAAM,IAAI,UAAU,KAAK,KAAK,EAAE;YAC/B,mBAAmB,GAAG,KAAK,CAAC;YAC5B,aAAa,GAAG;;;;OAIf,CAAC;YACF,OAAO,GAAG,OAAO,CAAC;SACnB;QAED,IAAI,gBAAgB,GAAG,EAAE,CAAC;QAC1B,IAAI,MAAM,GAAG,UAAU,GAAG,CAAC,EAAE;YAC3B,gBAAgB,GAAG;oCACW,MAAM;;;OAGnC,CAAC;SACH;QACD,IAAI,CAAC,QAAQ,GAAG;0CACsB,mBAAmB;;;;UAInD,gBAAgB;;;;;;;;kCAQQ,UAAU;;kCAEV,mBAAmB;;;;;;8BAMvB,qBAAqB;;YAEvC,OAAO,aAAa,OAAO;;;;;;;YAO3B,aAAa;;;iCAGQ,qBAAqB;cACxC,uBAAuB,KAAK,CAAC;YAC/B,OAAO,aAAa,OAAO;;;;;;;YAO3B,aAAa;qBACJ,uBAAuB,KAAK,CAAC;YACtC,OAAO,aAAa,OAAO;;;;;;;YAO3B,aAAa;qBACJ,uBAAuB,KAAK,CAAC;YACtC,OAAO,aAAa,OAAO;;;;;;;YAO3B,aAAa;;oBAEL,WAAW;;KAE1B,CAAC;IACJ,CAAC;CACF","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ReduceProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      reduceInfo: backend_util.ReduceInfo,\n      reduceType: 'all'|'any'|'max'|'min'|'sum'|'prod') {\n    const {windowSize, batchSize, inSize, outSize} = reduceInfo;\n    this.outputShape = [batchSize, outSize];\n\n    let initializationValue = '0.0';\n    let compareOp = ``;\n\n    if (reduceType === 'prod') {\n      initializationValue = '1.0';\n    } else if (reduceType === 'min') {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '1.0 / 1e-20';\n      compareOp = `min`;\n    } else if (reduceType === 'max') {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n      compareOp = `max`;\n    }\n\n    let returnValue = `${reduceType}(${reduceType}(${reduceType}(` +\n        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n\n    if (reduceType === 'sum') {\n      returnValue = `sumValue`;\n    } else if (reduceType === 'prod') {\n      returnValue = `prodValue`;\n    } else if (reduceType === 'all') {\n      returnValue = `allValue`;\n    } else if (reduceType === 'any') {\n      returnValue = `anyValue`;\n    }\n\n    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n    const windowSizeVec4Remainder = windowSize % 4;\n\n    let updateSnippet = `\n      if (${reduceType === 'sum'}) {\n        sumValue += dot(values, ones);\n      } else if (${reduceType === 'prod'}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n\n    let vecType = `vec4`;\n\n    if (reduceType === 'all') {\n      initializationValue = '1.0';\n      updateSnippet = `\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      `;\n      vecType = `bvec4`;\n    } else if (reduceType === 'any') {\n      initializationValue = '0.0';\n      updateSnippet = `\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      `;\n      vecType = `bvec4`;\n    }\n\n    let checkOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n    }\n    this.userCode = `\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${checkOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        vec4 minMaxValue = vec4(${initializationValue});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n"]}