{"version":3,"file":"pool_utils.js","sourceRoot":"","sources":["../../src/utils/pool_utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, buffer, DataType, Rank, TensorBuffer, TypedArray} from '@tensorflow/tfjs-core';\n\nexport function pool(\n    xValues: TypedArray, xShape: number[], dtype: DataType, strides: number[],\n    convInfo: backend_util.Conv2DInfo,\n    poolType: 'max'|'avg'): TensorBuffer<Rank, DataType> {\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n\n  const initialValue =\n      (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n                            Number.POSITIVE_INFINITY);\n\n  const output = buffer(convInfo.outShape, dtype);\n  const outputVals = output.values;\n\n  const outputBatchStrides =\n      convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];\n  const outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];\n  const outputColStrides = convInfo.outShape[3];\n\n  for (let b = 0; b < convInfo.batchSize; ++b) {\n    const outputBatchOffset = b * outputBatchStrides;\n    const inputBatchOffset = b * strides[0];\n    for (let d = 0; d < convInfo.inChannels; ++d) {\n      for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n        const xRCorner = yR * strideHeight - padTop;\n        const xRMin = Math.max(0, xRCorner);\n        const xRMax =\n            Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n        const outputRowOffset = outputBatchOffset + yR * outputRowStrides;\n        for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n          const xCCorner = yC * strideWidth - padLeft;\n          const xCMin = Math.max(0, xCCorner);\n          const xCMax =\n              Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n          let minMaxValue = initialValue;\n          let avgValue = 0;\n          let count = 0;\n          for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n            const xROffset = inputBatchOffset + xR * strides[1];\n            for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n              const xCOffset = xROffset + xC * strides[2];\n              const pixel = xValues[xCOffset + d];\n              if ((poolType === 'max' && pixel > minMaxValue)) {\n                minMaxValue = pixel;\n              } else if (poolType === 'avg') {\n                avgValue += pixel;\n                count++;\n              }\n            }\n            if (isNaN(minMaxValue)) {\n              break;\n            }\n          }\n          const outputOffset = outputRowOffset + yC * outputColStrides + d;\n          outputVals[outputOffset] =\n              poolType === 'avg' ? avgValue / count : minMaxValue;\n        }\n      }\n    }\n  }\n  return output;\n}\n\nexport function maxPoolPositions(\n    xValues: TypedArray, xShape: number[], dtype: DataType,\n    convInfo: backend_util.Conv2DInfo, flattenPositions = false,\n    includeBatchInIndex = false): TensorBuffer<Rank, 'int32'> {\n  const maxPositions = buffer(convInfo.outShape, 'int32');\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n\n  const xBuf = buffer(xShape, dtype, xValues);\n  for (let b = 0; b < convInfo.batchSize; ++b) {\n    for (let d = 0; d < convInfo.inChannels; ++d) {\n      for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n        const xRCorner = yR * strideHeight - padTop;\n        let xRMin = xRCorner;\n        while (xRMin < 0) {\n          xRMin += dilationHeight;\n        }\n        // const xRMin = Math.max(0, xRCorner);\n        const xRMax =\n            Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n        for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n          const xCCorner = yC * strideWidth - padLeft;\n          let xCMin = xCCorner;\n          while (xCMin < 0) {\n            xCMin += dilationWidth;\n          }\n          const xCMax =\n              Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n          let maxValue = Number.NEGATIVE_INFINITY;\n          let maxPosition = -1;\n\n          for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n            const wR = xR - xRCorner;\n            for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n              const wC = xC - xCCorner;\n              const pixel = xBuf.get(b, xR, xC, d);\n              if (pixel > maxValue) {\n                maxValue = pixel as number;\n                if (flattenPositions) {\n                  maxPosition = includeBatchInIndex ?\n                      ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) *\n                              convInfo.inChannels +\n                          d :\n                      (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;\n                } else {\n                  maxPosition = wR * effectiveFilterWidth + wC;\n                }\n              }\n            }\n          }\n          maxPositions.set(maxPosition, b, yR, yC, d);\n        }\n      }\n    }\n  }\n  return maxPositions;\n}\n\nexport function pool3d(\n    xValues: TypedArray, xShape: number[], dtype: DataType, strides: number[],\n    convInfo: backend_util.Conv3DInfo,\n    poolType: 'max'|'avg'): TensorBuffer<Rank, DataType> {\n  const strideDepth = convInfo.strideDepth;\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationDepth = convInfo.dilationDepth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padFront = convInfo.padInfo.front;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n\n  const initialValue =\n      (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n                            Number.POSITIVE_INFINITY);\n\n  const output = buffer(convInfo.outShape, dtype);\n  const outputVals = output.values;\n\n  const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] *\n      convInfo.outShape[3] * convInfo.outShape[4];\n  const outputDepthStrides =\n      convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n  const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];\n  const outputColStrides = convInfo.outShape[4];\n\n  for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n    const outputBatchOffset = batch * outputBatchStrides;\n    const inputBatchOffset = batch * strides[0];\n    for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n      for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n        const xDepthCorner = yDepth * strideDepth - padFront;\n        let xDepthMin = xDepthCorner;\n        while (xDepthMin < 0) {\n          xDepthMin += dilationDepth;\n        }\n        const xDepthMax =\n            Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n        const outputDepthOffset =\n            outputBatchOffset + yDepth * outputDepthStrides;\n        for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n          const xRowCorner = yRow * strideHeight - padTop;\n          let xRowMin = xRowCorner;\n          while (xRowMin < 0) {\n            xRowMin += dilationHeight;\n          }\n          const xRowMax =\n              Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n          const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;\n          for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n            const xColCorner = yCol * strideWidth - padLeft;\n            let xColMin = xColCorner;\n            while (xColMin < 0) {\n              xColMin += dilationWidth;\n            }\n            const xColMax =\n                Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n            // Shader code begins\n            const outputColOffset = outputRowOffset + yCol * outputColStrides;\n            let minMaxValue = initialValue;\n            let avgValue = 0;\n            let count = 0;\n            for (let xDepth = xDepthMin; xDepth < xDepthMax;\n                 xDepth += dilationDepth) {\n              const xDepthOffset = inputBatchOffset + xDepth * strides[1];\n              for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                const xRowOffset = xDepthOffset + xRow * strides[2];\n                for (let xCol = xColMin; xCol < xColMax;\n                     xCol += dilationWidth) {\n                  const xColOffset = xRowOffset + xCol * strides[3];\n                  const pixel = xValues[xColOffset + channel];\n                  if ((poolType === 'max' && pixel > minMaxValue)) {\n                    minMaxValue = pixel;\n                  } else if (poolType === 'avg') {\n                    avgValue += pixel;\n                    count++;\n                  }\n                  if (isNaN(minMaxValue)) {\n                    break;\n                  }\n                }\n                if (isNaN(minMaxValue)) {\n                  break;\n                }\n              }\n              if (isNaN(minMaxValue)) {\n                break;\n              }\n            }\n            const outputOffset = outputColOffset + channel;\n            outputVals[outputOffset] =\n                poolType === 'avg' ? avgValue / count : minMaxValue;\n          }\n        }\n      }\n    }\n  }\n\n  return output;\n}\n\nexport function maxPool3dPositions(\n    xBuf: TensorBuffer<Rank, DataType>,\n    convInfo: backend_util.Conv3DInfo): TensorBuffer<Rank, DataType> {\n  const maxPositions = buffer(convInfo.outShape, 'int32');\n  const strideDepth = convInfo.strideDepth;\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationDepth = convInfo.dilationDepth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padFront = convInfo.padInfo.front;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n\n  for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n    for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n      for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n        const xDepthCorner = yDepth * strideDepth - padFront;\n        let xDepthMin = xDepthCorner;\n        while (xDepthMin < 0) {\n          xDepthMin += dilationDepth;\n        }\n        const xDepthMax =\n            Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n        for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n          const xRowCorner = yRow * strideHeight - padTop;\n          let xRowMin = xRowCorner;\n          while (xRowMin < 0) {\n            xRowMin += dilationHeight;\n          }\n          const xRowMax =\n              Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n          for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n            const xColCorner = yCol * strideWidth - padLeft;\n            let xColMin = xColCorner;\n            while (xColMin < 0) {\n              xColMin += dilationWidth;\n            }\n            const xColMax =\n                Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n\n            // Shader code begins\n            let maxValue = Number.NEGATIVE_INFINITY;\n            let maxPosition = -1;\n\n            for (let xDepth = xDepthMin; xDepth < xDepthMax;\n                 xDepth += dilationDepth) {\n              const wDepth = xDepth - xDepthCorner;\n              for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                const wRow = xRow - xRowCorner;\n                for (let xCol = xColMin; xCol < xColMax;\n                     xCol += dilationWidth) {\n                  const wCol = xCol - xColCorner;\n                  const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);\n                  if (pixel >= maxValue) {\n                    maxValue = pixel as number;\n                    maxPosition =\n                        wDepth * effectiveFilterHeight * effectiveFilterWidth +\n                        wRow * effectiveFilterHeight + wCol;\n                  }\n                }\n              }\n            }\n\n            maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);\n          }\n        }\n      }\n    }\n  }\n\n  return maxPositions;\n}\n"]}